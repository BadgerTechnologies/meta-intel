From 2207600aa9ddf8be1796bcc4667bc0a3b60aef03 Mon Sep 17 00:00:00 2001
From: Dongwon Kim <dongwon.kim@intel.com>
Date: Thu, 19 Aug 2021 20:09:23 -0700
Subject: [PATCH 5/5] Temporary LLVM 12 compatiblity fix
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Upstream-Status: Submitted

Signed-off-by: Zoltán Böszörményi <zboszor@gmail.com>
Signed-off-by: Naveen Saini <naveen.kumar.saini@intel.com>
Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
---
 .../LegalizeFunctionSignatures.cpp            |  2 +-
 IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp          | 22 +++++-----
 IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp            |  4 +-
 IGC/Compiler/CISACodeGen/AdvMemOpt.cpp        |  3 +-
 IGC/Compiler/CISACodeGen/CShader.cpp          | 14 +++----
 .../CISACodeGen/ConstantCoalescing.cpp        | 14 +++----
 IGC/Compiler/CISACodeGen/DeSSA.cpp            |  5 ++-
 IGC/Compiler/CISACodeGen/EmitVISAPass.cpp     | 42 +++++++++----------
 IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp     |  4 +-
 IGC/Compiler/CISACodeGen/GenIRLowering.cpp    |  4 +-
 .../CISACodeGen/GenSimplification.cpp         |  5 ++-
 .../CISACodeGen/GeometryShaderLowering.cpp    |  3 +-
 IGC/Compiler/CISACodeGen/LdShrink.cpp         | 10 +++--
 .../CISACodeGen/LowerGEPForPrivMem.cpp        |  8 ++--
 IGC/Compiler/CISACodeGen/MemOpt.cpp           |  8 ++--
 IGC/Compiler/CISACodeGen/MemOpt2.cpp          |  5 ++-
 .../CISACodeGen/OpenCLKernelCodeGen.cpp       |  2 +-
 IGC/Compiler/CISACodeGen/PatternMatchPass.cpp |  6 +--
 IGC/Compiler/CISACodeGen/PushAnalysis.cpp     |  4 +-
 .../CISACodeGen/RegisterEstimator.cpp         |  3 +-
 .../CISACodeGen/RegisterPressureEstimate.hpp  |  3 +-
 IGC/Compiler/CISACodeGen/SLMConstProp.cpp     |  3 +-
 .../CISACodeGen/ScalarizerCodeGen.cpp         |  4 +-
 IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp    |  4 ++
 .../CISACodeGen/Simd32Profitability.cpp       | 10 +++--
 IGC/Compiler/CISACodeGen/SimplifyConstant.cpp | 12 +++---
 IGC/Compiler/CISACodeGen/TypeDemote.cpp       |  3 +-
 .../CISACodeGen/VariableReuseAnalysis.cpp     |  5 ++-
 .../CISACodeGen/VariableReuseAnalysis.hpp     |  3 +-
 IGC/Compiler/CISACodeGen/VectorPreProcess.cpp | 24 +++++------
 IGC/Compiler/CISACodeGen/VectorProcess.cpp    |  4 +-
 IGC/Compiler/CISACodeGen/helper.cpp           | 10 ++---
 IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp    |  7 ++--
 IGC/Compiler/CustomSafeOptPass.cpp            | 26 ++++++------
 IGC/Compiler/DebugInfo/ScalarVISAModule.cpp   |  3 +-
 IGC/Compiler/GenTTI.cpp                       |  3 +-
 IGC/Compiler/GenUpdateCB.cpp                  |  3 +-
 IGC/Compiler/HandleFRemInstructions.cpp       |  3 +-
 IGC/Compiler/HandleLoadStoreInstructions.cpp  |  4 +-
 IGC/Compiler/LegalizationPass.cpp             | 28 ++++++-------
 IGC/Compiler/Legalizer/InstPromoter.cpp       |  2 +-
 IGC/Compiler/Legalizer/InstScalarizer.cpp     |  6 +--
 .../Legalizer/PeepholeTypeLegalizer.cpp       |  6 +--
 IGC/Compiler/Legalizer/TypeLegalizer.cpp      |  3 +-
 IGC/Compiler/Legalizer/TypeLegalizer.h        |  3 +-
 IGC/Compiler/LowPrecisionOptPass.cpp          |  2 +-
 .../AddressSpaceAliasAnalysis.cpp             |  1 +
 .../AggregateArguments/AggregateArguments.cpp |  3 +-
 .../CorrectlyRoundedDivSqrt.cpp               |  3 +-
 .../DeviceEnqueueFuncs/TransformBlocks.cpp    |  4 +-
 .../Optimizer/OpenCLPasses/KernelArgs.cpp     |  3 +-
 .../OpenCLPrintf/OpenCLPrintfResolution.cpp   |  4 +-
 .../PrivateMemory/PrivateMemoryResolution.cpp |  6 +--
 .../ReplaceUnsupportedIntrinsics.cpp          |  4 +-
 .../OpenCLPasses/WIFuncs/WIFuncResolution.cpp |  2 +-
 .../Optimizer/PreCompiledFuncImport.cpp       |  4 +-
 IGC/Compiler/Optimizer/Scalarizer.cpp         | 32 +++++++-------
 IGC/Compiler/Optimizer/ValueTracker.cpp       |  2 +-
 IGC/Compiler/VerificationPass.cpp             |  2 +-
 IGC/DebugInfo/DebugInfoUtils.hpp              |  2 +-
 IGC/DebugInfo/DwarfDebug.cpp                  |  4 +-
 IGC/GenISAIntrinsics/GenIntrinsics.cpp        |  6 +--
 .../BuiltinsFrontendDefinitions.hpp           |  2 +-
 .../include/llvmWrapper/IR/DerivedTypes.h     | 10 +++++
 .../include/llvmWrapper/Support/TypeSize.h    |  6 ++-
 .../include/llvmWrapper/Transforms/Scalar.h   |  4 +-
 .../llvmWrapper/Transforms/Utils/LoopUtils.h  |  8 ++++
 IGC/common/igc_resourceDimTypes.h             |  6 ++-
 68 files changed, 263 insertions(+), 207 deletions(-)

diff --git a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
index d06c26de4..ee43be301 100644
--- a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
+++ b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
@@ -133,7 +133,7 @@ inline Type* LegalizedIntVectorType(Module& M, Type* ty)
 
     return ty->isIntegerTy() ?
         cast<Type>(IntegerType::get(M.getContext(), newSize)) :
-        IGCLLVM::FixedVectorType::get(IntegerType::get(M.getContext(), newSize), (unsigned)cast<VectorType>(ty)->getNumElements());
+        IGCLLVM::FixedVectorType::get(IntegerType::get(M.getContext(), newSize), (unsigned)cast<IGCLLVM::FixedVectorType>(ty)->getNumElements());
 }
 
 // Returns true for small structures that only contain primitive types
diff --git a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
index 66f31a0ce..65e672afe 100644
--- a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
@@ -1610,7 +1610,7 @@ void SPIRVToLLVMDbgTran::transDbgInfo(SPIRVValue *SV, Value *V) {
             Line->getColumn(), scope, iat);
 
         if(scope && !isa<DIFile>(scope))
-            I->setDebugLoc(DebugLoc::get(Line->getLine(), Line->getColumn(),
+            I->setDebugLoc(DILocation::get(scope->getContext(), Line->getLine(), Line->getColumn(),
                 scope, iat));
     }
 }
@@ -2063,7 +2063,7 @@ SPIRVToLLVM::transType(SPIRVType *T) {
         auto name = isSubgroupAvcINTELTypeOpCode(OC) ?
             OCLSubgroupINTELTypeOpCodeMap::rmap(OC) :
             BuiltinOpaqueGenericTypeOpCodeMap::rmap(OC);
-        auto *pST = M->getTypeByName(name);
+        auto *pST = IGCLLVM::getTypeByName(M, name);
         pST = pST ? pST : StructType::create(*Context, name);
 
         return mapType(T, PointerType::get(pST, getOCLOpaqueTypeAddrSpace(OC)));
@@ -2541,7 +2541,7 @@ Value *SPIRVToLLVM::promoteBool(Value *pVal, BasicBlock *BB)
 
     auto *PromoType = isa<VectorType>(pVal->getType()) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt8Ty(pVal->getContext()),
-        (unsigned)cast<VectorType>(pVal->getType())->getNumElements())) :
+        (unsigned)cast<IGCLLVM::FixedVectorType>(pVal->getType())->getNumElements())) :
         Type::getInt8Ty(pVal->getContext());
 
     if (auto *C = dyn_cast<Constant>(pVal))
@@ -2583,7 +2583,7 @@ Value *SPIRVToLLVM::truncBool(Value *pVal, BasicBlock *BB)
 
     auto *TruncType = isa<VectorType>(pVal->getType()) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt1Ty(pVal->getContext()),
-            (unsigned)cast<VectorType>(pVal->getType())->getNumElements())) :
+            (unsigned)cast<IGCLLVM::FixedVectorType>(pVal->getType())->getNumElements())) :
         Type::getInt1Ty(pVal->getContext());
 
     if (auto *C = dyn_cast<Constant>(pVal))
@@ -2629,7 +2629,7 @@ Type *SPIRVToLLVM::truncBoolType(SPIRVType *SPVType, Type *LLType)
 
     return isa<VectorType>(LLType) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt1Ty(LLType->getContext()),
-                                   (unsigned)cast<VectorType>(LLType)->getNumElements())) :
+                                   (unsigned)cast<IGCLLVM::FixedVectorType>(LLType)->getNumElements())) :
         Type::getInt1Ty(LLType->getContext());
 }
 
@@ -2837,7 +2837,7 @@ SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *BV, Function *F,
       {
         if(CV[i]->getType()->isVectorTy())
         {
-          for(uint32_t j = 0; j < cast<VectorType>(CV[i]->getType())->getNumElements(); j++)
+          for(uint32_t j = 0; j < cast<IGCLLVM::FixedVectorType>(CV[i]->getType())->getNumElements(); j++)
           {
             Value *v = ExtractElementInst::Create( CV[i],ConstantInt::get( *Context,APInt( 32,j ) ),BCC->getName(),BB );
             elm1 = CreateCompositeConstruct( elm1,v,pos++ );
@@ -3508,7 +3508,7 @@ SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *BV, Function *F,
       auto Vector = transValue(BI->getOperand(0), F, BB);
       auto Scalar = transValue(BI->getOperand(1), F, BB);
 
-      auto VecType = cast<VectorType>(Vector->getType());
+      auto VecType = cast<IGCLLVM::FixedVectorType>(Vector->getType());
       auto Undef   = UndefValue::get(VecType);
 
       auto ScalarVec = InsertElementInst::Create(Undef, Scalar,
@@ -3533,7 +3533,7 @@ SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *BV, Function *F,
           a->getType()->getScalarSizeInBits() - 1);
       auto *ShiftOp = isa<VectorType>(a->getType()) ?
           ConstantVector::getSplat(
-              IGCLLVM::getElementCount((unsigned)cast<VectorType>(a->getType())->getNumElements()), ShiftAmt) :
+              IGCLLVM::getElementCount((unsigned)cast<IGCLLVM::FixedVectorType>(a->getType())->getNumElements()), ShiftAmt) :
           ShiftAmt;
 
       // OCL C:
@@ -3887,15 +3887,15 @@ SPIRVToLLVM::transSPIRVBuiltinFromInst(SPIRVInstruction *BI, BasicBlock *BB) {
               "",
               BB);
       }
-      else if (cast<VectorType>(coordType)->getNumElements() != 4)
+      else if (cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements() != 4)
       {
           Value *undef = UndefValue::get(coordType);
 
           SmallVector<Constant*, 4> shuffleIdx;
-          for (unsigned i = 0; i < cast<VectorType>(coordType)->getNumElements(); i++)
+          for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements(); i++)
               shuffleIdx.push_back(ConstantInt::get(Type::getInt32Ty(*Context), i));
 
-          for (uint64_t i = (unsigned)cast<VectorType>(coordType)->getNumElements(); i < 4; i++)
+          for (uint64_t i = (unsigned)cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements(); i < 4; i++)
               shuffleIdx.push_back(ConstantInt::get(Type::getInt32Ty(*Context), 0));
 
           imageCoordinateWiden = new ShuffleVectorInst(
diff --git a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
index 73ffca030..ecb045b88 100644
--- a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
@@ -76,7 +76,7 @@ saveLLVMModule(Module *M, const std::string &OutputFile) {
 PointerType*
 getOrCreateOpaquePtrType(Module *M, const std::string &Name,
     unsigned AddrSpace) {
-  auto OpaqueType = M->getTypeByName(Name);
+  auto OpaqueType = IGCLLVM::getTypeByName(M, Name);
   if (!OpaqueType)
     OpaqueType = StructType::create(M->getContext(), Name);
   return PointerType::get(OpaqueType, AddrSpace);
@@ -142,7 +142,7 @@ std::string recursive_mangle(const Type* pType)
             return "i" + utostr(pType->getIntegerBitWidth());
         case IGCLLVM::VectorTyID:
         {
-            unsigned vecLen = (unsigned)cast<VectorType>(pType)->getNumElements();
+            unsigned vecLen = (unsigned)cast<IGCLLVM::FixedVectorType>(pType)->getNumElements();
             Type* pEltType = cast<VectorType>(pType)->getElementType();
             return "v" + utostr(vecLen) + recursive_mangle(pEltType);
         }
diff --git a/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp b/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp
index 876cb0a30..9621c4d53 100644
--- a/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp
+++ b/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp
@@ -17,6 +17,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/raw_ostream.h>
 #include <llvm/Transforms/Utils/Local.h>
+#include "llvmWrapper/Transforms/Utils/LoopUtils.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 #include "Compiler/CISACodeGen/ShaderCodeGen.hpp"
@@ -118,7 +119,7 @@ bool AdvMemOpt::runOnFunction(Function& F) {
     for (auto I = LI->begin(), E = LI->end(); I != E; ++I)
         for (auto DFI = df_begin(*I), DFE = df_end(*I); DFI != DFE; ++DFI) {
             Loop* L = *DFI;
-            if (L->empty())
+            if (IGCLLVM::isInnermost(L))
                 InnermostLoops.push_back(L);
         }
 
diff --git a/IGC/Compiler/CISACodeGen/CShader.cpp b/IGC/Compiler/CISACodeGen/CShader.cpp
index 04b59cf00..16b77b050 100644
--- a/IGC/Compiler/CISACodeGen/CShader.cpp
+++ b/IGC/Compiler/CISACodeGen/CShader.cpp
@@ -427,7 +427,7 @@ void CShader::CreateAliasVars()
                         continue;
 
                     Type* Ty = V->getType();
-                    VectorType* VTy = dyn_cast<VectorType>(Ty);
+                    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
                     Type* BTy = VTy ? VTy->getElementType() : Ty;
                     int nelts = (VTy ? (int)VTy->getNumElements() : 1);
 
@@ -1039,7 +1039,7 @@ bool CShader::InsideWorkgroupDivergentCF(const llvm::Instruction* inst) const
 uint CShader::GetNbVectorElementAndMask(llvm::Value* val, uint32_t& mask)
 {
     llvm::Type* type = val->getType();
-    uint nbElement = int_cast<uint>(cast<VectorType>(type)->getNumElements());
+    uint nbElement = int_cast<uint>(cast<IGCLLVM::FixedVectorType>(type)->getNumElements());
     mask = 0;
     // we don't process vector bigger than 31 elements as the mask has only 32bits
     // If we want to support longer vectors we need to extend the mask size
@@ -1244,7 +1244,7 @@ CShader::ExtractMaskWrapper::ExtractMaskWrapper(CShader* pS, Value* VecVal)
         m_EM = it->second;
         return;
     }
-    VectorType* VTy = dyn_cast<VectorType>(VecVal->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(VecVal->getType());
     const unsigned int numChannels = VTy ? (unsigned)VTy->getNumElements() : 1;
     if (numChannels <= 32)
     {
@@ -1768,7 +1768,7 @@ CVariable* CShader::GetStructVariable(llvm::Value* v, bool forceVectorInit)
 
 CVariable* CShader::GetConstant(llvm::Constant* C, CVariable* dstVar)
 {
-    llvm::VectorType* VTy = llvm::dyn_cast<llvm::VectorType>(C->getType());
+    IGCLLVM::FixedVectorType* VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(C->getType());
     if (C && VTy)
     {   // Vector constant
         llvm::Type* eTy = VTy->getElementType();
@@ -1996,7 +1996,7 @@ uint32_t CShader::GetNumElts(llvm::Type* type, bool isUniform)
     {
         IGC_ASSERT(type->getContainedType(0)->isIntegerTy() || type->getContainedType(0)->isFloatingPointTy());
 
-        auto VT = cast<VectorType>(type);
+        auto VT = cast<IGCLLVM::FixedVectorType>(type);
         numElts *= (uint16_t)VT->getNumElements();
     }
     else if (type->isStructTy())
@@ -2709,7 +2709,7 @@ CVariable* CShader::GetSymbol(llvm::Value* value, bool fromConstantPool)
                 if (isVecType)
                 {
                     // Map the entire vector value to the CVar
-                    unsigned numElements = (unsigned)cast<VectorType>(value->getType())->getNumElements();
+                    unsigned numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(value->getType())->getNumElements();
                     var = GetNewVariable(numElements, ISA_TYPE_UQ,
                         (GetContext()->platform.getGRFSize() == 64) ? EALIGN_32WORD : EALIGN_HWORD,
                         WIBaseClass::UNIFORM_GLOBAL, 1, valName);
@@ -3619,7 +3619,7 @@ unsigned int CShader::GetPrimitiveTypeSizeInRegisterInBits(const Type* Ty) const
     {
         sizeInBits =
             GetContext()->getRegisterPointerSizeInBits(Ty->getPointerAddressSpace());
-        if (auto* VTy = dyn_cast<VectorType>(Ty))
+        if (auto* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty))
         {
             sizeInBits *= (unsigned)VTy->getNumElements();
         }
diff --git a/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp b/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp
index 43fcfc7c0..8d58414b6 100644
--- a/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp
+++ b/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp
@@ -182,7 +182,7 @@ static void checkInsertExtractMatch(InsertElementInst* insertInst, Value* base,
 
 static bool canReplaceInsert(InsertElementInst* insertElt)
 {
-    VectorType* VTy = cast<VectorType>(insertElt->getOperand(0)->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(insertElt->getOperand(0)->getType());
     ConstantInt* index = dyn_cast<ConstantInt>(insertElt->getOperand(2));
     if (!index || index->getZExtValue() != VTy->getNumElements() - 1)
     {
@@ -270,7 +270,7 @@ void ConstantCoalescing::VectorizePrep(llvm::BasicBlock* bb)
         {
             if (load->getType()->isVectorTy() && wiAns->isUniform(load))
             {
-                srcNElts = (uint32_t)cast<VectorType>(load->getType())->getNumElements();
+                srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(load->getType())->getNumElements();
                 DenseMap<uint64_t, Instruction*> extractElementMap;
 
                 for (auto iter = load->user_begin(); iter != load->user_end(); iter++)
@@ -354,7 +354,7 @@ bool ConstantCoalescing::isProfitableLoad(
             (isa<LoadInst>(I) && wiAns->isUniform(I)) ?
             16 : 4;
 
-        if (cast<VectorType>(LoadTy)->getNumElements() > MaxVectorInput)
+        if (cast<IGCLLVM::FixedVectorType>(LoadTy)->getNumElements() > MaxVectorInput)
             return false;
 
         MaxEltPlus = CheckVectorElementUses(I);
@@ -1933,7 +1933,7 @@ void ConstantCoalescing::AdjustChunk(BufChunk* cov_chunk, uint start_adj, uint s
         WIAnalysis::WIDependancy loadDep = wiAns->whichDepend(cov_chunk->chunkIO);
         irBuilder->SetInsertPoint(cov_chunk->chunkIO->getNextNode());
         Value* vec = UndefValue::get(originalType);
-        for (unsigned i = 0; i < cast<VectorType>(originalType)->getNumElements(); i++)
+        for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(originalType)->getNumElements(); i++)
         {
             Value* channel = irBuilder->CreateExtractElement(
                 cov_chunk->chunkIO, irBuilder->getInt32(i + start_adj));
@@ -1997,7 +1997,7 @@ void ConstantCoalescing::MoveExtracts(BufChunk* cov_chunk, Instruction* load, ui
             irBuilder->SetInsertPoint(load->getNextNode());
             Type* vecType = load->getType();
             Value* vec = UndefValue::get(vecType);
-            for (unsigned i = 0; i < cast<VectorType>(vecType)->getNumElements(); i++)
+            for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(vecType)->getNumElements(); i++)
             {
                 Value* channel = irBuilder->CreateExtractElement(
                     cov_chunk->chunkIO, irBuilder->getInt32(i + start_adj));
@@ -2061,7 +2061,7 @@ void ConstantCoalescing::EnlargeChunk(BufChunk* cov_chunk, uint size_adj)
         WIAnalysis::WIDependancy loadDep = wiAns->whichDepend(cov_chunk->chunkIO);
         irBuilder->SetInsertPoint(cov_chunk->chunkIO->getNextNode());
         Value* vec = UndefValue::get(originalType);
-        for (unsigned i = 0; i < cast<VectorType>(originalType)->getNumElements(); i++)
+        for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(originalType)->getNumElements(); i++)
         {
             Value* channel = irBuilder->CreateExtractElement(
                 cov_chunk->chunkIO, irBuilder->getInt32(i));
@@ -2498,7 +2498,7 @@ void ConstantCoalescing::ReplaceLoadWithSamplerLoad(
         if (dstTy->isVectorTy())
         {
             result = UndefValue::get(dstTy);
-            for (uint i = 0; i < cast<VectorType>(dstTy)->getNumElements(); i++)
+            for (uint i = 0; i < cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements(); i++)
             {
                 Value* tmpData = ExtractFromSamplerData(cast<VectorType>(dstTy)->getElementType(), i);
                 result = irBuilder->CreateInsertElement(result, tmpData, irBuilder->getInt32(i));
diff --git a/IGC/Compiler/CISACodeGen/DeSSA.cpp b/IGC/Compiler/CISACodeGen/DeSSA.cpp
index bc06a00d2..8ac30bac2 100644
--- a/IGC/Compiler/CISACodeGen/DeSSA.cpp
+++ b/IGC/Compiler/CISACodeGen/DeSSA.cpp
@@ -67,6 +67,7 @@ See LICENSE.TXT for details.
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/IR/Instructions.h"
 #include <llvm/IR/InstIterator.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include <llvm/IR/InlineAsm.h>
 #include "common/LLVMWarningsPop.hpp"
 #include <algorithm>
@@ -1302,7 +1303,7 @@ int DeSSA::checkInsertElementAlias(
     //
     // If found, return the actual vector size;
     // otherwise, return 0.
-    VectorType* VTy = cast<VectorType>(IEI->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(IEI->getType());
     IGC_ASSERT(nullptr != VTy);
     int nelts = (int)VTy->getNumElements();
     AllIEIs.resize(nelts, nullptr);
@@ -1491,4 +1492,4 @@ bool DeSSA::alignInterfere(e_alignment a1, e_alignment a2)
         return true;
     }
     return false;
-}
\ No newline at end of file
+}
diff --git a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
index dda1529eb..5541dee74 100644
--- a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
+++ b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
@@ -1265,7 +1265,7 @@ bool EmitPass::canRelocatePhiMov(
                 if (dst != src)
                 {
                     int numElt = 1;
-                    if (VectorType * vTy = dyn_cast<VectorType>(PN->getType()))
+                    if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(PN->getType()))
                     {
                         numElt = int_cast<int>(vTy->getNumElements());
                     }
@@ -1402,7 +1402,7 @@ void EmitPass::MovPhiSources(llvm::BasicBlock* aBB)
                         phiSrcDstList.push_back(phiInfo);
 
                         int numElt = 0;
-                        if (VectorType * vTy = dyn_cast<VectorType>(PN->getType()))
+                        if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(PN->getType()))
                         {
                             numElt = int_cast<int>(vTy->getNumElements());
                         }
@@ -5606,7 +5606,7 @@ void EmitPass::emitLegacySimdBlockWrite(llvm::Instruction* inst, llvm::Value* pt
     bool useA64 = isA64Ptr(ptrType, m_currShader->GetContext());
 
     Type* Ty = dataPtr->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t nbElements = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
 
     uint32_t typeSizeInBytes = Ty->getScalarSizeInBits() / 8;
@@ -5852,7 +5852,7 @@ void EmitPass::emitLegacySimdBlockRead(llvm::Instruction* inst, llvm::Value* ptr
     bool useA64 = isA64Ptr(ptrType, m_currShader->GetContext());
 
     Type* Ty = inst->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t nbElements = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
 
     uint32_t typeSizeInBytes = Ty->getScalarSizeInBits() / 8;
@@ -6144,7 +6144,7 @@ void EmitPass::emitMediaBlockIO(const llvm::GenIntrinsicInst* inst, bool isRead)
         };
 
         uint nElts = isa<VectorType>(pDataType) ?
-            (uint)cast<VectorType>(pDataType)->getNumElements() :
+            (uint)cast<IGCLLVM::FixedVectorType>(pDataType)->getNumElements() :
             1;
 
         // Now, do the copies.
@@ -6234,7 +6234,7 @@ void EmitPass::emitSimdMediaBlockRead(llvm::Instruction* inst)
     uint32_t nbElements = 1;
     if (inst->getType()->isVectorTy())
     {
-        nbElements = (uint32_t)cast<VectorType>(inst->getType())->getNumElements();
+        nbElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
     }
     IGC_ASSERT_MESSAGE(nbElements <= 8, "InValid Vector Size");
 
@@ -6478,7 +6478,7 @@ void EmitPass::emitSimdMediaBlockWrite(llvm::Instruction* inst)
     uint32_t nbElements = 1;
     if (dataPtr->getType()->isVectorTy())
     {
-        nbElements = (uint32_t)cast<VectorType>(dataPtr->getType())->getNumElements();
+        nbElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(dataPtr->getType())->getNumElements();
     }
     IGC_ASSERT_MESSAGE(nbElements <= 8, "InValid Vector Size");
 
@@ -9140,7 +9140,7 @@ void EmitPass::EmitInlineAsm(llvm::CallInst* inst)
                 {
                     if (inst->getType()->isVectorTy())
                     {
-                        emitVectorCopy(dest, cv, int_cast<unsigned>(dyn_cast<VectorType>(inst->getType())->getNumElements()));
+                        emitVectorCopy(dest, cv, int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements()));
                     }
                     else
                     {
@@ -9415,9 +9415,9 @@ void EmitPass::emitBitCast(llvm::BitCastInst* btCst)
 {
     Type* srcType = btCst->getOperand(0)->getType();
     Type* dstType = btCst->getType();
-    unsigned int numSrcElement = srcType->isVectorTy() ? (unsigned)cast<VectorType>(srcType)->getNumElements() : 1;
-    unsigned int numDstElement = dstType->isVectorTy() ? (unsigned)cast<VectorType>(dstType)->getNumElements() : 1;
-
+    unsigned int numSrcElement = srcType->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(srcType)->getNumElements() : 1;
+    unsigned int numDstElement = dstType->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(dstType)->getNumElements() : 1;
+ 
     if (srcType->isPointerTy())
     {
         IGC_ASSERT_MESSAGE(dstType->isPointerTy(), "Expected both src and dst have pointer type.");
@@ -9863,7 +9863,7 @@ void EmitPass::emitLoad3DInner(LdRawIntrinsic* inst, ResourceDescriptor& resourc
     {
         IGC_ASSERT_MESSAGE(predDefSurface != ESURFACE_STATELESS, "scratch cannot be uniform");
         Type* loadType = inst->getType();
-        uint numElement = loadType->isVectorTy() ? (uint)cast<VectorType>(loadType)->getNumElements() : 1;
+        uint numElement = loadType->isVectorTy() ? (uint)cast<IGCLLVM::FixedVectorType>(loadType)->getNumElements() : 1;
         if (predDefSurface == ESURFACE_SLM)
         {
             IGC_ASSERT(numElement <= 4);
@@ -11278,7 +11278,7 @@ void EmitPass::emitInsert(llvm::Instruction* inst)
             pVecVar = GetSymbol(pVec);
             if (pVecVar != pInstVar)
             {
-                emitVectorCopy(pInstVar, pVecVar, int_cast<unsigned>(dyn_cast<VectorType>(pVecType)->getNumElements()));
+                emitVectorCopy(pInstVar, pVecVar, int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(pVecType)->getNumElements()));
             }
         }
     }
@@ -15233,7 +15233,7 @@ bool EmitPass::isUniformStoreOCL(Value* ptr, Value* storeVal)
     }
 
     Type* Ty = storeVal->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t elts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
 
@@ -15269,7 +15269,7 @@ void EmitPass::emitVectorBitCast(llvm::BitCastInst* BCI)
     if (srcTy->isVectorTy())
     {
         srcEltTy = cast<VectorType>(srcTy)->getElementType();
-        srcNElts = (uint32_t)cast<VectorType>(srcTy)->getNumElements();
+        srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(srcTy)->getNumElements();
     }
     else
     {
@@ -15279,7 +15279,7 @@ void EmitPass::emitVectorBitCast(llvm::BitCastInst* BCI)
     if (dstTy->isVectorTy())
     {
         dstEltTy = cast<VectorType>(dstTy)->getElementType();
-        dstNElts = (uint32_t)cast<VectorType>(dstTy)->getNumElements();
+        dstNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements();
     }
     else
     {
@@ -15867,7 +15867,7 @@ void EmitPass::emitVectorLoad(LoadInst* inst, Value* offset, ConstantInt* immOff
     }
 
     Type* Ty = inst->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
     uint32_t eltBytes = GetScalarTypeSizeInRegister(eltTy);
     IGC_ASSERT_MESSAGE((eltBytes == 1) || (eltBytes == 2) || (eltBytes == 4) || (eltBytes == 8),
@@ -16381,7 +16381,7 @@ void EmitPass::emitVectorStore(StoreInst* inst, Value* offset, ConstantInt* immO
 
     Value* storedVal = inst->getValueOperand();
     Type* Ty = storedVal->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
     uint32_t eltBytes = GetScalarTypeSizeInRegister(eltTy);
 
@@ -17189,7 +17189,7 @@ void EmitPass::emitCopyAll(CVariable* Dst, CVariable* Src, llvm::Type* Ty)
     }
     else if (Ty->isVectorTy())
     {
-        unsigned NElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+        unsigned NElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
         emitVectorCopy(Dst, Src, NElts);
     }
     else if (Ty->isStructTy())
@@ -18347,9 +18347,9 @@ void EmitPass::emitfcvt(llvm::GenIntrinsicInst* GII)
     CVariable* dst = m_destination;
 
     Type* dTy = GII->getType();
-    VectorType* dVTy = dyn_cast<VectorType>(dTy);
+    IGCLLVM::FixedVectorType* dVTy = dyn_cast<IGCLLVM::FixedVectorType>(dTy);
     Type* sTy = sVal->getType();
-    VectorType* sVTy = dyn_cast<VectorType>(sTy);
+    IGCLLVM::FixedVectorType* sVTy = dyn_cast<IGCLLVM::FixedVectorType>(sTy);
     int nelts = dVTy ? (int)dVTy->getNumElements() : 1;
     int src_nelts = sVTy ? (int)sVTy->getNumElements() : 1;
     if (nelts != src_nelts)
diff --git a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
index 1c30ae361..db77b514d 100644
--- a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
+++ b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
@@ -1945,7 +1945,7 @@ bool InstExpander::visitExtractElement(ExtractElementInst& EEI) {
     // later.
 
     Value* V = EEI.getVectorOperand();
-    unsigned NumElts = (unsigned)cast<VectorType>(V->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(V->getType())->getNumElements();
     V = IRB->CreateBitCast(V, Emu->getV2Int32Ty(NumElts));
     // Re-calculate indices to Lo and Hi parts.
     Value* Idx = EEI.getIndexOperand();
@@ -1982,7 +1982,7 @@ bool InstExpander::visitInsertElement(InsertElementInst& IEI) {
 
     // Create the emulated vector.
     Value* NewVal = IEI.getOperand(0);
-    unsigned NumElts = (unsigned)cast<VectorType>(NewVal->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(NewVal->getType())->getNumElements();
     NewVal = IRB->CreateBitCast(NewVal, Emu->getV2Int32Ty(NumElts));
     // Re-calculate indices to Lo and Hi parts.
     Value* Idx = IEI.getOperand(2);
diff --git a/IGC/Compiler/CISACodeGen/GenIRLowering.cpp b/IGC/Compiler/CISACodeGen/GenIRLowering.cpp
index 71e3bdf06..311964b9c 100644
--- a/IGC/Compiler/CISACodeGen/GenIRLowering.cpp
+++ b/IGC/Compiler/CISACodeGen/GenIRLowering.cpp
@@ -437,7 +437,7 @@ Value* GEPLowering::getSExtOrTrunc(Value* Val, Type* NewTy) const {
 
     IGC_ASSERT_MESSAGE(OldTy->isIntOrIntVectorTy(), "Index should be Integer or vector of Integer!");
 
-    if (auto OldVecTy = dyn_cast<VectorType>(OldTy)) {
+    if (auto OldVecTy = dyn_cast<IGCLLVM::FixedVectorType>(OldTy)) {
         OldWidth = (unsigned)OldVecTy->getNumElements() * OldVecTy->getElementType()->getIntegerBitWidth();
         NewWidth = (unsigned)OldVecTy->getNumElements() * NewTy->getIntegerBitWidth();
     }
@@ -789,7 +789,7 @@ bool GEPLowering::lowerGetElementPtrInst(GetElementPtrInst* GEP) const
                 }
                 else
                 {
-                    if (auto NewIdxVT = dyn_cast<VectorType>(NewIdx->getType())) {
+                    if (auto NewIdxVT = dyn_cast<IGCLLVM::FixedVectorType>(NewIdx->getType())) {
                         Value* result = llvm::UndefValue::get(FixedVectorType::get(PtrMathTy, (unsigned)NewIdxVT->getNumElements()));
                         for (uint32_t j = 0; j < (uint32_t)NewIdxVT->getNumElements(); j++) {
                             result = Builder->CreateInsertElement(result, PointerValue, Builder->getInt32(j));
diff --git a/IGC/Compiler/CISACodeGen/GenSimplification.cpp b/IGC/Compiler/CISACodeGen/GenSimplification.cpp
index 23ab58538..f97482b6c 100644
--- a/IGC/Compiler/CISACodeGen/GenSimplification.cpp
+++ b/IGC/Compiler/CISACodeGen/GenSimplification.cpp
@@ -19,6 +19,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/InstVisitor.h>
 #include <llvm/IR/Instruction.h>
 #include <llvm/Support/raw_ostream.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
 
@@ -148,7 +149,7 @@ bool GenSimplification::simplifyVectorPHINodeCase2(PHINode& PN) const {
 
     Type* Ty = PN.getType();
     Type* EltTy = Ty->getScalarType();
-    unsigned NumElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
 
     SmallVector<Value*, 8> Lanes;
     SmallVector<SmallVector<Value*, 8>, 4> Values;
@@ -222,7 +223,7 @@ void GenSimplification::visitPHINode(PHINode& PN) {
 void GenSimplification::visitExtractElement(ExtractElementInst& EEI) {
     // Skip non-2-element vector.
     Value* Vec = EEI.getVectorOperand();
-    VectorType* VTy = cast<VectorType>(Vec->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(Vec->getType());
     if (VTy->getNumElements() != 2)
         return;
 
diff --git a/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp b/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp
index 20638a0fe..6982ed252 100644
--- a/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp
+++ b/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp
@@ -17,6 +17,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/PassManager.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/Verifier.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/InitializePasses.h"
 #include "Probe/Assertion.h"
@@ -444,7 +445,7 @@ void GeometryShaderLowering::AddURBRead(
     {
         Value* vec = UndefValue::get(inst->getType());
         IRBuilder<> builder(inst);
-        for (unsigned int i = 0; i < cast<VectorType>(inst->getType())->getNumElements(); i++)
+        for (unsigned int i = 0; i < cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements(); i++)
         {
             Value* vecElement = builder.CreateExtractElement(urbRead, builder.getInt32(i));
             vec = builder.CreateInsertElement(vec, vecElement, builder.getInt32(i));
diff --git a/IGC/Compiler/CISACodeGen/LdShrink.cpp b/IGC/Compiler/CISACodeGen/LdShrink.cpp
index 91226eeb2..f7099d6fb 100644
--- a/IGC/Compiler/CISACodeGen/LdShrink.cpp
+++ b/IGC/Compiler/CISACodeGen/LdShrink.cpp
@@ -14,6 +14,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/MathExtras.h>
 #include <llvm/Support/raw_ostream.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/CISACodeGen/ShaderCodeGen.hpp"
 #include "Compiler/IGCPassSupport.h"
@@ -63,7 +64,7 @@ IGC_INITIALIZE_PASS_BEGIN(LdShrink, PASS_FLAG, PASS_DESC, PASS_CFG_ONLY, PASS_AN
 IGC_INITIALIZE_PASS_END(LdShrink, PASS_FLAG, PASS_DESC, PASS_CFG_ONLY, PASS_ANALYSIS)
 
 unsigned LdShrink::getExtractIndexMask(LoadInst* LI) const {
-    VectorType* VTy = dyn_cast<VectorType>(LI->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(LI->getType());
     // Skip non-vector loads.
     if (!VTy)
         return 0;
@@ -75,9 +76,12 @@ unsigned LdShrink::getExtractIndexMask(LoadInst* LI) const {
     Type* Ty = VTy->getScalarType();
     // Skip non-BYTE addressable data types. So far, check integer types
     // only.
-    if (IntegerType * ITy = dyn_cast<IntegerType>(Ty))
-        if (!ITy->isPowerOf2ByteWidth())
+    if (IntegerType * ITy = dyn_cast<IntegerType>(Ty)) {
+        // Unroll isPowerOf2ByteWidth, it was removed in LLVM 12.
+        unsigned BitWidth = ITy->getBitWidth();
+        if (!((BitWidth > 7) && isPowerOf2_32(BitWidth)))
             return 0;
+    }
 
     unsigned Mask = 0; // Maxmimally 32 elements.
 
diff --git a/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp b/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp
index ffd4bdc41..15d7f6d6d 100644
--- a/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp
+++ b/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp
@@ -603,7 +603,7 @@ void TransposeHelper::handleGEPInst(
             }
             else
             {
-                arr_sz = (unsigned)cast<VectorType>(T)->getNumElements();
+                arr_sz = (unsigned)cast<IGCLLVM::FixedVectorType>(T)->getNumElements();
             }
             T = cast<VectorType>(T)->getElementType();
         }
@@ -625,7 +625,7 @@ void TransposeHelper::handleGEPInst(
         }
         else if (T->isVectorTy())
         {
-            arr_sz = (unsigned)cast<VectorType>(T)->getNumElements();
+            arr_sz = (unsigned)cast<IGCLLVM::FixedVectorType>(T)->getNumElements();
             T = cast<VectorType>(T)->getElementType();
         }
         else
@@ -685,7 +685,7 @@ void TransposeHelperPromote::handleLoadInst(
     IRBuilder<> IRB(pLoad);
     IGC_ASSERT(nullptr != pLoad->getType());
     unsigned N = pLoad->getType()->isVectorTy()
-        ? (unsigned)cast<VectorType>(pLoad->getType())->getNumElements()
+        ? (unsigned)cast<IGCLLVM::FixedVectorType>(pLoad->getType())->getNumElements()
         : 1;
     Value* Val = loadEltsFromVecAlloca(N, pVecAlloca, pScalarizedIdx, IRB, pLoad->getType()->getScalarType());
     pLoad->replaceAllUsesWith(Val);
@@ -717,7 +717,7 @@ void TransposeHelperPromote::handleStoreInst(
         // %v1 = extractelement <2 x float> %v, i32 1
         // %w1 = insertelement <32 x float> %w0, float %v1, i32 %idx+1
         // store <32 x float> %w1, <32 x float>* %ptr1
-        for (unsigned i = 0, e = (unsigned)cast<VectorType>(pStoreVal->getType())->getNumElements(); i < e; ++i)
+        for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(pStoreVal->getType())->getNumElements(); i < e; ++i)
         {
             Value* VectorIdx = ConstantInt::get(pScalarizedIdx->getType(), i);
             auto Val = IRB.CreateExtractElement(pStoreVal, VectorIdx);
diff --git a/IGC/Compiler/CISACodeGen/MemOpt.cpp b/IGC/Compiler/CISACodeGen/MemOpt.cpp
index 32f24ba1c..c85eb1238 100644
--- a/IGC/Compiler/CISACodeGen/MemOpt.cpp
+++ b/IGC/Compiler/CISACodeGen/MemOpt.cpp
@@ -108,7 +108,7 @@ namespace {
             MemRefListTy& MemRefs, TrivialMemRefListTy& ToOpt);
 
         unsigned getNumElements(Type* Ty) const {
-            return Ty->isVectorTy() ? (unsigned)cast<VectorType>(Ty)->getNumElements() : 1;
+            return Ty->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements() : 1;
         }
 
         MemoryLocation getLocation(Instruction* I) const {
@@ -922,7 +922,7 @@ bool MemOpt::mergeLoad(LoadInst* LeadingLoad,
             Pos = unsigned((std::get<1>(I) - FirstOffset) / LdScalarSize);
 
         if (Ty->isVectorTy()) {
-            if (Pos + cast<VectorType>(Ty)->getNumElements() > NumElts) {
+            if (Pos + cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements() > NumElts) {
                 // This implies we're trying to extract an element from our new load
                 // with an index > the size of the new load.  If this happens,
                 // we'll generate correct code if it does since we don't remove the
@@ -930,7 +930,7 @@ bool MemOpt::mergeLoad(LoadInst* LeadingLoad,
                 continue;
             }
             Value* Val = UndefValue::get(Ty);
-            for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i) {
+            for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i) {
                 Value* Ex = Builder.CreateExtractElement(NewLoad, Builder.getInt32(Pos + i));
                 Ex = createBitOrPointerCast(Ex, ScalarTy, Builder);
                 Val = Builder.CreateInsertElement(Val, Ex, Builder.getInt32(i));
@@ -1312,7 +1312,7 @@ bool MemOpt::mergeStore(StoreInst* LeadingStore,
         IGC_ASSERT(hasSameSize(ScalarTy, LeadingStoreScalarType));
 
         if (Ty->isVectorTy()) {
-            for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i) {
+            for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i) {
                 Value* Ex = Builder.CreateExtractElement(Val, Builder.getInt32(i));
                 Ex = createBitOrPointerCast(Ex, LeadingStoreScalarType, Builder);
                 NewStoreVal = Builder.CreateInsertElement(NewStoreVal, Ex,
diff --git a/IGC/Compiler/CISACodeGen/MemOpt2.cpp b/IGC/Compiler/CISACodeGen/MemOpt2.cpp
index 989727107..96e1ec303 100644
--- a/IGC/Compiler/CISACodeGen/MemOpt2.cpp
+++ b/IGC/Compiler/CISACodeGen/MemOpt2.cpp
@@ -16,6 +16,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/raw_ostream.h>
 #include <llvm/Transforms/Utils/Local.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 
@@ -108,7 +109,7 @@ namespace {
             if (!Ty->isSingleValueType())
                 return UINT_MAX;
             // Simply return 1 so far for scalar types.
-            VectorType* VecTy = dyn_cast<VectorType>(Ty);
+            IGCLLVM::FixedVectorType* VecTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             if (!VecTy)
                 return 1;
             // Check how that vector is used.
@@ -137,7 +138,7 @@ namespace {
                 return UINT_MAX;
             unsigned EltByte = (Ty->getScalarSizeInBits() + 7) / 8;
             // Simply return 1 so far for scalar types.
-            VectorType* VecTy = dyn_cast<VectorType>(Ty);
+            IGCLLVM::FixedVectorType* VecTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             if (!VecTy)
                 return EltByte;
             // Check how that vector is used.
diff --git a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
index 01272b03b..8dc187ebf 100644
--- a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
@@ -409,7 +409,7 @@ namespace IGC
         unsigned int numElements = 1;
         if (baseType->isVectorTy())
         {
-            numElements = (unsigned)cast<VectorType>(baseType)->getNumElements();
+            numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(baseType)->getNumElements();
             baseType = cast<VectorType>(baseType)->getElementType();
         }
 
diff --git a/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp b/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp
index cd048136a..51632e3d9 100644
--- a/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp
+++ b/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp
@@ -2438,7 +2438,7 @@ namespace IGC
         // Store3d supports only types equal or less than 128 bits.
         if (auto* storeInst = dyn_cast<StoreInst>(&I))
         {
-            llvm::VectorType* vectorToStore = dyn_cast<llvm::VectorType>(storeInst->getValueOperand()->getType());
+            IGCLLVM::FixedVectorType* vectorToStore = dyn_cast<IGCLLVM::FixedVectorType>(storeInst->getValueOperand()->getType());
 
             // If stored value is a vector of pointers, the size must be calculated manually,
             // because getPrimitiveSizeInBits returns 0 for pointers.
@@ -3072,8 +3072,8 @@ namespace IGC
                 llvm::Type* srcTy = bTInst->getOperand(0)->getType();
                 llvm::Type* dstTy = bTInst->getType();
 
-                srcNElts = (srcTy->isVectorTy()) ? (uint32_t)cast<VectorType>(srcTy)->getNumElements() : 1;
-                dstNElts = (dstTy->isVectorTy()) ? (uint32_t)cast<VectorType>(dstTy)->getNumElements() : 1;
+                srcNElts = (srcTy->isVectorTy()) ? (uint32_t)cast<IGCLLVM::FixedVectorType>(srcTy)->getNumElements() : 1;
+                dstNElts = (dstTy->isVectorTy()) ? (uint32_t)cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements() : 1;
 
                 if (srcNElts < dstNElts && srcTy->getScalarSizeInBits() < 64)
                 {
diff --git a/IGC/Compiler/CISACodeGen/PushAnalysis.cpp b/IGC/Compiler/CISACodeGen/PushAnalysis.cpp
index 4f905cc9a..0ee5ffbc0 100644
--- a/IGC/Compiler/CISACodeGen/PushAnalysis.cpp
+++ b/IGC/Compiler/CISACodeGen/PushAnalysis.cpp
@@ -987,7 +987,7 @@ namespace IGC
 
         if (pTypeToPush->isVectorTy())
         {
-            num_elms = (unsigned)cast<VectorType>(pTypeToPush)->getNumElements();
+            num_elms = (unsigned)cast<IGCLLVM::FixedVectorType>(pTypeToPush)->getNumElements();
             pTypeToPush = cast<VectorType>(pTypeToPush)->getElementType();
             llvm::Type* pVecTy = IGCLLVM::FixedVectorType::get(pTypeToPush, num_elms);
             pReplacedInst = llvm::UndefValue::get(pVecTy);
@@ -1178,7 +1178,7 @@ namespace IGC
         }
 
         unsigned num_elms =
-            inst->getType()->isVectorTy() ? (unsigned)cast<VectorType>(inst->getType())->getNumElements() : 1;
+            inst->getType()->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements() : 1;
         llvm::Type* pTypeToPush = inst->getType();
         llvm::Value* replaceVector = nullptr;
         unsigned int numberChannelReplaced = 0;
diff --git a/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp b/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp
index dee494d73..ef33489c3 100644
--- a/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp
+++ b/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp
@@ -25,6 +25,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Support/MathExtras.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
 
@@ -130,7 +131,7 @@ RegUse RegisterEstimator::estimateNumOfRegs(Value* V) const
     Type* Ty = V->getType();
     if (!Ty->isVoidTy())
     {
-        VectorType* VTy = dyn_cast<VectorType>(Ty);
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         Type* eltTy = VTy ? VTy->getElementType() : Ty;
         uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
         uint32_t eltBits = (uint32_t)m_DL->getTypeSizeInBits(eltTy);
diff --git a/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp b/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp
index 6148817e1..80898be35 100644
--- a/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp
+++ b/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp
@@ -24,6 +24,7 @@ See LICENSE.TXT for details.
 #include "llvm/Pass.h"
 #include <llvm/IR/InstVisitor.h>
 #include "llvm/Analysis/LoopInfo.h"
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/IGCPassSupport.h"
 #include "Compiler/CISACodeGen/WIAnalysis.hpp"
@@ -222,7 +223,7 @@ namespace IGC
             auto Ty = V->getType();
             if (Ty->isVoidTy())
                 return 0;
-            auto VTy = llvm::dyn_cast<llvm::VectorType>(Ty);
+            auto VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             auto eltTy = VTy ? VTy->getElementType() : Ty;
             uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
             uint32_t eltBits = (uint32_t)m_DL->getTypeSizeInBits(eltTy);
diff --git a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
index 84e481b7d..3acc4f305 100644
--- a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
+++ b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
@@ -23,6 +23,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/MathExtras.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include <vector>
 #include "Probe/Assertion.h"
@@ -613,7 +614,7 @@ bool SLMConstProp::isEqual(Constant* C0, Constant* C1)
 
 bool SLMConstProp::isFloatType(Type* Ty)
 {
-    if (VectorType * vTy = dyn_cast<VectorType>(Ty))
+    if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty))
     {
         if (vTy->getNumElements() > 1)
         {
diff --git a/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp b/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp
index 33b711b94..0651d2c34 100644
--- a/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp
@@ -50,7 +50,7 @@ void ScalarizerCodeGen::visitBinaryOperator(llvm::BinaryOperator& I)
         {
             bool isNewTypeVector = false;
 
-            VectorType* instType = cast<VectorType>(I.getType());
+            IGCLLVM::FixedVectorType* instType = cast<IGCLLVM::FixedVectorType>(I.getType());
             unsigned numElements = int_cast<unsigned>(instType->getNumElements());
             unsigned scalarSize = instType->getScalarSizeInBits();
             unsigned newScalarBits = numElements * scalarSize;
@@ -95,7 +95,7 @@ void ScalarizerCodeGen::visitBinaryOperator(llvm::BinaryOperator& I)
                 }
                 else
                 {
-                    VectorType* newVecType = cast<VectorType>(newType);
+                    IGCLLVM::FixedVectorType* newVecType = cast<IGCLLVM::FixedVectorType>(newType);
                     unsigned newVecTypeNumEle = int_cast<unsigned>(newVecType->getNumElements());
                     Value* ieLogicOp = UndefValue::get(newType);
                     for (unsigned i = 0; i < newVecTypeNumEle; i++)
diff --git a/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp b/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp
index 14a68e0da..4f42a6770 100644
--- a/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp
@@ -639,12 +639,14 @@ static void AddLegalizationPasses(CodeGenContext& ctx, IGCPassManager& mpm, PSSi
     {
         mpm.add(createPruneUnusedArgumentsPass());
 
+#if LLVM_VERSION_MAJOR < 12
         if (IGC_GET_FLAG_VALUE(FunctionControl) == FLAG_FCALL_DEFAULT)
         {
             // Don't run IPConstantProp when debugging function calls, to avoid folding function arg/ret constants
             mpm.add(createIPConstantPropagationPass());
         }
         mpm.add(createConstantPropagationPass());
+#endif
         mpm.add(createDeadCodeEliminationPass());
         mpm.add(createCFGSimplificationPass());
     }
@@ -1549,8 +1551,10 @@ void OptimizeIR(CodeGenContext* const pContext)
             // possible which potentially allows late stage code sinking of
             // those calls by the instruction combiner.
             mpm.add(createPostOrderFunctionAttrsLegacyPass());
+#if LLVM_VERSION_MAJOR < 12
             mpm.add(createConstantPropagationPass());
             mpm.add(createIPConstantPropagationPass());
+#endif
         }
 
         // enable this only when Pooled EU is not supported
diff --git a/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp b/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp
index e1d1a8e60..97dbc0e74 100644
--- a/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp
+++ b/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp
@@ -12,8 +12,10 @@ SPDX-License-Identifier: MIT
 #include "Compiler/CISACodeGen/Platform.hpp"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvmWrapper/IR/DerivedTypes.h>
+#include <llvmWrapper/Transforms/Utils/LoopUtils.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/IR/Operator.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 #include "GenISAIntrinsics/GenIntrinsicInst.h"
@@ -561,7 +563,7 @@ static bool isPayloadHeader(Value* V) {
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 8 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -572,7 +574,7 @@ static bool isR0(Value* V) {
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 8 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -583,7 +585,7 @@ static bool isEnqueuedLocalSize(Value* V) {
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 3 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -982,7 +984,7 @@ static bool hasLongStridedLdStInLoop(Function* F, LoopInfo* LI, WIAnalysis* WI)
     // Collect innermost simple loop.
     for (auto I = LI->begin(), E = LI->end(); I != E; ++I) {
         auto L = *I;
-        if (!L->empty())
+        if (!IGCLLVM::isInnermost(L))
             continue;
         if (L->getNumBlocks() != 2)
             continue;
diff --git a/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp b/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp
index c42e8f373..a4f758a5a 100644
--- a/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp
+++ b/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp
@@ -336,7 +336,7 @@ static unsigned getLegalVectorSize(unsigned N) {
 // Check vector size. We may demote the data type if all values can fit into
 // smaller data type.
 //
-static bool checkSize(GlobalVariable* GV, VectorType*& DataType,
+static bool checkSize(GlobalVariable* GV, IGCLLVM::FixedVectorType*& DataType,
     bool& IsSigned) {
     Constant* Init = GV->getInitializer();
     IGC_ASSERT(isa<ArrayType>(Init->getType()));
@@ -344,7 +344,7 @@ static bool checkSize(GlobalVariable* GV, VectorType*& DataType,
     unsigned N = (unsigned)ArrayTy->getArrayNumElements();
     Type* BaseTy = ArrayTy->getArrayElementType();
     unsigned VectorSize = 1;
-    if (auto VT = dyn_cast<VectorType>(BaseTy)) {
+    if (auto VT = dyn_cast<IGCLLVM::FixedVectorType>(BaseTy)) {
         BaseTy = VT->getElementType();
         VectorSize = int_cast<unsigned>(VT->getNumElements());
         N *= VectorSize;
@@ -467,7 +467,7 @@ static Constant* getConstantVal(Type* VEltTy, Constant* V, bool IsSigned) {
     return ConstantInt::get(VEltTy, IVal, IsSigned);
 }
 
-static void promote(GlobalVariable* GV, VectorType* AllocaType, bool IsSigned,
+static void promote(GlobalVariable* GV, IGCLLVM::FixedVectorType* AllocaType, bool IsSigned,
     Function* F) {
     // Build the constant vector from constant array.
     unsigned VS = int_cast<unsigned>(AllocaType->getNumElements());
@@ -491,7 +491,7 @@ static void promote(GlobalVariable* GV, VectorType* AllocaType, bool IsSigned,
             Constant* const Elt = CA->getAggregateElement(i);
             IGC_ASSERT_MESSAGE(nullptr != Elt, "Null AggregateElement");
             if (auto EltTy = dyn_cast<VectorType>(Elt->getType())) {
-                unsigned VectorSize = (unsigned)cast<VectorType>(EltTy)->getNumElements();
+                unsigned VectorSize = (unsigned)cast<IGCLLVM::FixedVectorType>(EltTy)->getNumElements();
                 for (unsigned j = 0; j < VectorSize; ++j) {
                     Constant* V = Elt->getAggregateElement(j);
                     Vals[i * VectorSize + j] = getConstantVal(VEltTy, V, IsSigned);
@@ -533,7 +533,7 @@ static void promote(GlobalVariable* GV, VectorType* AllocaType, bool IsSigned,
             unsigned N = 1;
             Value* Offset = Index;
             if (Ty->isVectorTy()) {
-                N = (unsigned)cast<VectorType>(Ty)->getNumElements();
+                N = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
                 Offset = Builder.CreateMul(Offset, ConstantInt::get(Offset->getType(), N));
             }
             Value* Val = extractNElts(N, VectorData, Offset, Builder);
@@ -668,7 +668,7 @@ bool PromoteConstant::runOnFunction(Function& F) {
 
         // If possible demote the data into smaller type. Uses of value will be
         // promoted back with ZExt or SExt.
-        VectorType* AllocaType = nullptr;
+        IGCLLVM::FixedVectorType* AllocaType = nullptr;
         bool IsSigned = false;
         if (!checkSize(GV, AllocaType, IsSigned))
             continue;
diff --git a/IGC/Compiler/CISACodeGen/TypeDemote.cpp b/IGC/Compiler/CISACodeGen/TypeDemote.cpp
index cd8f2eff0..e539bd6ed 100644
--- a/IGC/Compiler/CISACodeGen/TypeDemote.cpp
+++ b/IGC/Compiler/CISACodeGen/TypeDemote.cpp
@@ -16,6 +16,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/ADT/PostOrderIterator.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/Pass.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 #include "Probe/Assertion.h"
@@ -272,7 +273,7 @@ bool TypeDemote::demoteOnBasicBlock(BasicBlock* BB) const {
             CastInst* CI = dyn_cast<CastInst>(Index);
             if (CI && (CI->getOpcode() == Instruction::ZExt ||
                 CI->getOpcode() == Instruction::SExt)) {
-                unsigned VS = (unsigned)cast<VectorType>(EEI->getVectorOperandType())->getNumElements();
+                unsigned VS = (unsigned)cast<IGCLLVM::FixedVectorType>(EEI->getVectorOperandType())->getNumElements();
                 unsigned N = (unsigned int)CI->getSrcTy()->getPrimitiveSizeInBits();
                 unsigned Bound = (N < 32) ? (1U << N) : UINT32_MAX;
                 if (VS <= Bound) {
diff --git a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp
index 666eb62e3..8b44cfef3 100644
--- a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp
+++ b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp
@@ -12,6 +12,7 @@ SPDX-License-Identifier: MIT
 #include "Compiler/CodeGenPublic.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/Support/Debug.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include <algorithm>
 #include "Probe/Assertion.h"
@@ -24,13 +25,13 @@ namespace
     // If V is scalar, return 1.
     // if V is vector, return the number of elements.
     inline int getNumElts(Value* V) {
-        VectorType* VTy = dyn_cast<VectorType>(V->getType());
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(V->getType());
         return VTy ? (int)VTy->getNumElements() : 1;
     }
 
     inline int getTypeSizeInBits(Type* Ty) {
         int scalarBits = Ty->getScalarSizeInBits();
-        VectorType* VTy = dyn_cast<VectorType>(Ty);
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         return scalarBits * (VTy ? (int)VTy->getNumElements() : 1);
     }
 }
diff --git a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp
index ca523f239..d16d286fa 100644
--- a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp
+++ b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp
@@ -21,6 +21,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/InstIterator.h>
 #include <llvm/IR/InstVisitor.h>
 #include "llvm/Pass.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/Support/raw_ostream.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/CISACodeGen/RegisterEstimator.hpp"
@@ -63,7 +64,7 @@ namespace IGC {
         SSubVecDesc(llvm::Value* V)
             : Aliaser(V), BaseVector(V), StartElementOffset(0)
         {
-            llvm::VectorType* VTy = llvm::dyn_cast<llvm::VectorType>(V->getType());
+            IGCLLVM::FixedVectorType* VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(V->getType());
             NumElts = VTy ? (short)VTy->getNumElements() : 1;
         }
 
diff --git a/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp b/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp
index 204b2f29a..2ea975555 100644
--- a/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp
+++ b/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp
@@ -485,7 +485,7 @@ void VectorPreProcess::replaceAllVectorUsesWithScalars(Instruction* VI, ValVecto
             I = VI->getParent()->getFirstNonPHI();
         }
         IRBuilder<> Builder(I);
-        VectorType* VTy = cast<VectorType>(VI->getType());
+        IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(VI->getType());
         Value* newVec = UndefValue::get(VTy);
         for (uint32_t i = 0, e = int_cast<uint32_t>(VTy->getNumElements()); i < e; ++i)
         {
@@ -626,7 +626,7 @@ bool VectorPreProcess::splitStore(
 {
     Instruction* SI = ASI.getInst();
     Value* StoredVal = ASI.getValueOperand();
-    VectorType* VTy = cast<VectorType>(StoredVal->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(StoredVal->getType());
     Type* ETy = VTy->getElementType();
     uint32_t nelts = int_cast<uint32_t>(VTy->getNumElements());
 
@@ -712,7 +712,7 @@ bool VectorPreProcess::splitStore(
         {
             Type* Ty1 = splitInfo[i].first;
             uint32_t len1 = splitInfo[i].second;
-            VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+            IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
             for (uint32_t j = 0; j < len1; ++j)
             {
                 Value* subVec;
@@ -749,7 +749,7 @@ bool VectorPreProcess::splitStore(
     {
         Type* Ty1 = splitInfo[i].first;
         uint32_t len1 = splitInfo[i].second;
-        VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+        IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
         for (uint32_t j = 0; j < len1; ++j)
         {
             uint32_t vAlign = (uint32_t)MinAlign(Align, (uint32_t)eOffset * EBytes);
@@ -793,7 +793,7 @@ bool VectorPreProcess::splitLoad(
 {
     Instruction* LI = ALI.getInst();
     bool isLdRaw = isa<LdRawIntrinsic>(LI);
-    VectorType* VTy = cast<VectorType>(LI->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(LI->getType());
     Type* ETy = VTy->getElementType();
     uint32_t nelts = int_cast<uint32_t>(VTy->getNumElements());
 
@@ -855,7 +855,7 @@ bool VectorPreProcess::splitLoad(
     {
         Type* Ty1 = splitInfo[i].first;
         uint32_t len1 = splitInfo[i].second;
-        VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+        IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
         for (uint32_t j = 0; j < len1; ++j)
         {
             uint32_t vAlign = (uint32_t)MinAlign(Align, eOffset * EBytes);
@@ -923,7 +923,7 @@ bool VectorPreProcess::splitLoadStore(
     Optional<AbstractStoreInst> ASI = AbstractStoreInst::get(Inst);
     IGC_ASSERT_MESSAGE((ALI || ASI), "Inst should be either load or store");
     Type* Ty = ALI ? ALI->getInst()->getType() : ASI->getValueOperand()->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     if (!VTy)
     {
         return false;
@@ -1154,7 +1154,7 @@ void VectorPreProcess::getOrGenScalarValues(
 {
     availBeforeInst = nullptr;
 
-    VectorType* VTy = cast<VectorType>(VecVal->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(VecVal->getType());
     if (!VTy)
     {
         scalars[0] = VecVal;
@@ -1305,7 +1305,7 @@ Instruction* VectorPreProcess::simplifyLoadStore(Instruction* Inst)
         //
         // TODO: further optimize this load into a message with channel masks
         // for cases in which use indices are sparse like {0, 2}.
-        unsigned N = (unsigned)cast<VectorType>(Inst->getType())->getNumElements();
+        unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(Inst->getType())->getNumElements();
         if (N == MaxIndex + 1)
             return Inst;
 
@@ -1420,7 +1420,7 @@ Instruction* VectorPreProcess::simplifyLoadStore(Instruction* Inst)
     if (NBits < 32)
         return Inst;
 
-    unsigned N = (unsigned)cast<VectorType>(Val->getType())->getNumElements();
+    unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(Val->getType())->getNumElements();
     if (auto CV = dyn_cast<ConstantVector>(Val))
     {
         unsigned MaxIndex = 0;
@@ -1589,7 +1589,7 @@ bool VectorPreProcess::runOnFunction(Function& F)
                 for (uint32_t j = 0; j < svals.size(); ++j)
                 {
                     Type* Ty1 = svals[j]->getType();
-                    VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+                    IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
                     if (VTy1) {
                         for (uint32_t k = 0; k < VTy1->getNumElements(); ++k)
                         {
@@ -1638,7 +1638,7 @@ bool VectorPreProcess::runOnFunction(Function& F)
                     // If this is a 3-element vector load, remove it
                     // from m_Vector3List as well.
                     if (isAbstractLoadInst(tInst) && tInst->getType()->isVectorTy() &&
-                        cast<VectorType>(tInst->getType())->getNumElements() == 3)
+                        cast<IGCLLVM::FixedVectorType>(tInst->getType())->getNumElements() == 3)
                     {
                         InstWorkVector::iterator
                             tI = m_Vector3List.begin(),
diff --git a/IGC/Compiler/CISACodeGen/VectorProcess.cpp b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
index c30a07834..8046b2e65 100644
--- a/IGC/Compiler/CISACodeGen/VectorProcess.cpp
+++ b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
@@ -224,7 +224,7 @@ bool VectorProcess::reLayoutLoadStore(Instruction* Inst)
     IGC_ASSERT(nullptr != Ptr);
     IGC_ASSERT(nullptr != Ty);
 
-    VectorType* const VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* const VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
 
     // Treat a scalar as 1-element vector
     uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
@@ -638,7 +638,7 @@ void VectorMessage::getInfo(Type* Ty, uint32_t Align, bool useA32,
     VectorType* VTy = dyn_cast<VectorType>(Ty);
     Type* eTy = VTy ? cast<VectorType>(VTy)->getElementType() : Ty;
     unsigned eltSize = m_emitter->GetScalarTypeSizeInRegister(eTy);
-    unsigned nElts = VTy ? (unsigned)cast<VectorType>(VTy)->getNumElements() : 1;
+    unsigned nElts = VTy ? (unsigned)cast<IGCLLVM::FixedVectorType>(VTy)->getNumElements() : 1;
     // total bytes
     const unsigned TBytes = nElts * eltSize;
 
diff --git a/IGC/Compiler/CISACodeGen/helper.cpp b/IGC/Compiler/CISACodeGen/helper.cpp
index f3da862c6..288a69a79 100644
--- a/IGC/Compiler/CISACodeGen/helper.cpp
+++ b/IGC/Compiler/CISACodeGen/helper.cpp
@@ -1744,7 +1744,7 @@ namespace IGC
             {
                 instList[i] = builder.CreateExtractElement(val, static_cast<uint64_t>(0));
                 size_t iOld = i;
-                for (unsigned j = 1; j < cast<VectorType>(val->getType())->getNumElements(); j++)
+                for (unsigned j = 1; j < cast<IGCLLVM::FixedVectorType>(val->getType())->getNumElements(); j++)
                 {
                     instList.insert(instList.begin()+ iOld +j, builder.CreateExtractElement(val, j));
                     i++;
@@ -1777,7 +1777,7 @@ namespace IGC
             }
             break;
         case IGCLLVM::VectorTyID:
-            num = (unsigned)cast<VectorType>(type)->getNumElements();
+            num = (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements();
             for (unsigned i = 0; i < num; i++)
             {
                 ScalarizeAggregateMembers(builder, builder.CreateExtractElement(val, i), instList);
@@ -1817,7 +1817,7 @@ namespace IGC
             }
             break;
         case IGCLLVM::VectorTyID:
-            num = (unsigned)cast<VectorType>(type)->getNumElements();
+            num = (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements();
             for (unsigned i = 0; i < num; i++)
             {
                 indices.push_back(builder.getInt32(i));
@@ -2082,8 +2082,8 @@ namespace IGC
                 return false;
             }
 
-            VectorType* dVTy = dyn_cast<VectorType>(dTy);
-            VectorType* sVTy = dyn_cast<VectorType>(sTy);
+            IGCLLVM::FixedVectorType* dVTy = dyn_cast<IGCLLVM::FixedVectorType>(dTy);
+            IGCLLVM::FixedVectorType* sVTy = dyn_cast<IGCLLVM::FixedVectorType>(sTy);
             int d_nelts = dVTy ? (int)dVTy->getNumElements() : 1;
             int s_nelts = sVTy ? (int)sVTy->getNumElements() : 1;
             if (d_nelts != s_nelts) {
diff --git a/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp b/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp
index 75089a77e..efb27ae4e 100644
--- a/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp
+++ b/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp
@@ -138,12 +138,11 @@ void ConvertMSAAPayloadTo16Bit::visitCallInst(CallInst& I)
             // There are uses of ldmcs other then ldms, using vector of int32 type.
             // Fix them to use newly created 16bit ldmcs.
             if (ldmcs->getType()->isVectorTy() &&
-                cast<VectorType>(ldmcs->getType())->getElementType() == m_builder->getInt32Ty())
+                cast<IGCLLVM::FixedVectorType>(ldmcs->getType())->getElementType()->isFloatTy())
             {
                 m_builder->SetInsertPoint(ldmcs);
-
-                uint32_t ldmcsNumOfElements =    (uint32_t)cast<VectorType>(ldmcs->getType())->getNumElements();
-                uint32_t newLdmcsNumOfElements = (uint32_t)cast<VectorType>(new_mcs_call->getType())->getNumElements();
+                uint32_t ldmcsNumOfElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(ldmcs->getType())->getNumElements();
+                uint32_t newLdmcsNumOfElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(new_mcs_call->getType())->getNumElements();
 
                 // vec of 16bit ints to vec of 32bit ints
                 Type* newLdmcsVecType = IGCLLVM::FixedVectorType::get(m_builder->getInt32Ty(), newLdmcsNumOfElements);
diff --git a/IGC/Compiler/CustomSafeOptPass.cpp b/IGC/Compiler/CustomSafeOptPass.cpp
index 3fe49f460..c65a466cc 100644
--- a/IGC/Compiler/CustomSafeOptPass.cpp
+++ b/IGC/Compiler/CustomSafeOptPass.cpp
@@ -1544,7 +1544,7 @@ void IGC::CustomSafeOptPass::visitSampleBptr(llvm::SampleIntrinsic* sampleInst)
 bool CustomSafeOptPass::isIdentityMatrix(ExtractElementInst& I)
 {
     bool found = false;
-    auto extractType = cast<VectorType>(I.getVectorOperandType());
+    auto extractType = cast<IGCLLVM::FixedVectorType>(I.getVectorOperandType());
     auto extractTypeVecSize = (uint32_t)extractType->getNumElements();
     if (extractTypeVecSize == 20 ||
         extractTypeVecSize == 16)
@@ -1773,7 +1773,7 @@ void CustomSafeOptPass::visitExtractElementInst(ExtractElementInst& I)
                     int elOffset = (int)(bitShift / eltSize);
                     elOffset = rightShift ? elOffset : -elOffset;
                     unsigned int newIndex = (unsigned int)((int)cstIndex->getZExtValue() + elOffset);
-                    if (newIndex < cast<VectorType>(vecType)->getNumElements())
+                    if (newIndex < cast<IGCLLVM::FixedVectorType>(vecType)->getNumElements())
                     {
                         IRBuilder<> builder(&I);
                         Value* newBitCast = builder.CreateBitCast(binOp->getOperand(0), vecType);
@@ -2173,7 +2173,7 @@ void GenSpecificPattern::createBitcastExtractInsertPattern(BinaryOperator& I, Va
         else if (auto IEIInst = dyn_cast<InsertElementInst>(Op))
         {
             auto opType = IEIInst->getType();
-            if (opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<VectorType>(opType)->getNumElements() == 2)
+            if (opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<IGCLLVM::FixedVectorType>(opType)->getNumElements() == 2)
             {
                 elem = IEIInst->getOperand(1);
             }
@@ -2236,7 +2236,7 @@ void GenSpecificPattern::visitBinaryOperator(BinaryOperator& I)
         else if (match(&I, pattern2) && AndOp2->getType()->isIntegerTy(64))
         {
             ConstantVector* cVec = dyn_cast<ConstantVector>(VecOp);
-            VectorType* vector_type = dyn_cast<VectorType>(VecOp->getType());
+            IGCLLVM::FixedVectorType* vector_type = dyn_cast<IGCLLVM::FixedVectorType>(VecOp->getType());
             if (cVec && vector_type &&
                 isa<ConstantInt>(cVec->getOperand(0)) &&
                 cast<ConstantInt>(cVec->getOperand(0))->isZero() &&
@@ -2382,7 +2382,7 @@ void GenSpecificPattern::visitBinaryOperator(BinaryOperator& I)
             BitCastInst* opBC = cast<BitCastInst>(op);
 
             auto opType = opBC->getType();
-            if (!(opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<VectorType>(opType)->getNumElements() == 2))
+            if (!(opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<IGCLLVM::FixedVectorType>(opType)->getNumElements() == 2))
                 return nullptr;
 
             if (opBC->getSrcTy()->isDoubleTy())
@@ -2808,8 +2808,8 @@ void GenSpecificPattern::visitBitCastInst(BitCastInst& I)
                 if (zExtInst->getOperand(0)->getType()->isIntegerTy(32) &&
                     isa<InsertElementInst>(bitCastInst->getOperand(0)) &&
                     bitCastInst->getOperand(0)->getType()->isVectorTy() &&
-                    cast<VectorType>(bitCastInst->getOperand(0)->getType())->getElementType()->isIntegerTy(32) &&
-                    cast<VectorType>(bitCastInst->getOperand(0)->getType())->getNumElements() == 2)
+                    cast<IGCLLVM::FixedVectorType>(bitCastInst->getOperand(0)->getType())->getElementType()->isIntegerTy(32) &&
+                    cast<IGCLLVM::FixedVectorType>(bitCastInst->getOperand(0)->getType())->getNumElements() == 2)
                 {
                     InsertElementInst* insertElementInst = cast<InsertElementInst>(bitCastInst->getOperand(0));
 
@@ -2979,7 +2979,7 @@ void GenSpecificPattern::visitFNeg(llvm::UnaryOperator& I)
     }
     else
     {
-        uint32_t vectorSize = cast<VectorType>(I.getType())->getNumElements();
+        uint32_t vectorSize = cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
         fsub = llvm::UndefValue::get(I.getType());
 
         for (uint32_t i = 0; i < vectorSize; ++i)
@@ -3056,7 +3056,7 @@ Constant* IGCConstProp::replaceShaderConstant(Instruction* inst)
                 if (inst->getType()->isVectorTy())
                 {
                     Type* srcEltTy = cast<VectorType>(inst->getType())->getElementType();
-                    uint32_t srcNElts = (uint32_t)cast<VectorType>(inst->getType())->getNumElements();
+                    uint32_t srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
                     uint32_t eltSize_in_bytes = (unsigned int)srcEltTy->getPrimitiveSizeInBits() / 8;
                     IRBuilder<> builder(inst);
                     Value* vectorValue = UndefValue::get(inst->getType());
@@ -3341,7 +3341,7 @@ Constant* IGCConstProp::ConstantFoldCmpInst(CmpInst* CI)
     {
         bool AllTrue = true, AllFalse = true;
         auto VecOpnd = cast<Constant>(EEI->getVectorOperand());
-        unsigned N = (unsigned)cast<VectorType>(VecOpnd->getType())->getNumElements();
+        unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(VecOpnd->getType())->getNumElements();
         for (unsigned i = 0; i < N; ++i)
         {
             Constant* const Opnd = VecOpnd->getAggregateElement(i);
@@ -4137,8 +4137,8 @@ namespace IGC
                 BitCastInst* BC = dyn_cast<BitCastInst>(&*BI++);
                 if (!BC) continue;
                 // Skip non-element-wise bitcast.
-                VectorType* DstVTy = dyn_cast<VectorType>(BC->getType());
-                VectorType* SrcVTy = dyn_cast<VectorType>(BC->getOperand(0)->getType());
+                IGCLLVM::FixedVectorType* DstVTy = dyn_cast<IGCLLVM::FixedVectorType>(BC->getType());
+                IGCLLVM::FixedVectorType* SrcVTy = dyn_cast<IGCLLVM::FixedVectorType>(BC->getOperand(0)->getType());
                 if (!DstVTy || !SrcVTy || DstVTy->getNumElements() != SrcVTy->getNumElements())
                     continue;
                 // Skip if it's not used only all extractelement.
@@ -4928,7 +4928,7 @@ void SplitIndirectEEtoSel::visitExtractElementInst(llvm::ExtractElementInst& I)
 {
     using namespace llvm::PatternMatch;
 
-    VectorType* vecTy = I.getVectorOperandType();
+    IGCLLVM::FixedVectorType* vecTy = dyn_cast<IGCLLVM::FixedVectorType>(I.getVectorOperandType());
     uint64_t num = vecTy->getNumElements();
     Type* eleType = vecTy->getElementType();
 
diff --git a/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp b/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp
index d094f36e7..b66f4585a 100644
--- a/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp
+++ b/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp
@@ -15,6 +15,7 @@ SPDX-License-Identifier: MIT
 #include "DebugInfo/DebugInfoUtils.hpp"
 
 #include "common/LLVMWarningsPush.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/Module.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -565,7 +566,7 @@ ScalarVisaModule::GetVariableLocation(const llvm::Instruction* pInst) const
 
         if (pType->isVectorTy())
         {
-            vectorNumElements = (unsigned)cast<VectorType>(pType)->getNumElements();
+            vectorNumElements = (unsigned)cast<IGCLLVM::FixedVectorType>(pType)->getNumElements();
         }
         else if (!pVar->IsUniform())
         {
diff --git a/IGC/Compiler/GenTTI.cpp b/IGC/Compiler/GenTTI.cpp
index d51396080..8a74ec287 100644
--- a/IGC/Compiler/GenTTI.cpp
+++ b/IGC/Compiler/GenTTI.cpp
@@ -21,6 +21,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Analysis/LoopInfo.h"
 #include "llvm/Analysis/ScalarEvolution.h"
 #include "llvm/Support/raw_ostream.h"
+#include "llvmWrapper/Transforms/Utils/LoopUtils.h"
 #include "common/LLVMWarningsPop.hpp"
 
 using namespace llvm;
@@ -201,7 +202,7 @@ namespace llvm {
 
         // Skip non-simple loop.
         if (L->getNumBlocks() != 1) {
-            if (IGC_IS_FLAG_ENABLED(EnableAdvRuntimeUnroll) && L->empty()) {
+            if (IGC_IS_FLAG_ENABLED(EnableAdvRuntimeUnroll) && IGCLLVM::isInnermost(L)) {
                 auto countNonPHI = [](BasicBlock* BB) {
                     unsigned Total = BB->size();
                     unsigned PHIs = 0;
diff --git a/IGC/Compiler/GenUpdateCB.cpp b/IGC/Compiler/GenUpdateCB.cpp
index f15738472..d83ced93e 100644
--- a/IGC/Compiler/GenUpdateCB.cpp
+++ b/IGC/Compiler/GenUpdateCB.cpp
@@ -8,6 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/Bitcode/BitcodeWriter.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include <llvm/Support/ScaledNumber.h>
 #include <llvm/Bitcode/BitcodeReader.h>
 #include "llvm/IR/DebugInfo.h"
@@ -368,7 +369,7 @@ bool GenUpdateCB::runOnFunction(Function& F)
                     isResInfo(dyn_cast<GenIntrinsicInst>(inst,
                         GenISAIntrinsic::GenISA_resinfoptr), texId, lod, isUAV))
                 {
-                    unsigned nelems = (unsigned)cast<VectorType>(inst->getType())->getNumElements();
+                    unsigned nelems = (unsigned)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
                     SmallVector< SmallVector<ExtractElementInst*, 1>, 4> extracts(nelems);
                     if (VectorUsedByConstExtractOnly(inst, extracts))
                     {
diff --git a/IGC/Compiler/HandleFRemInstructions.cpp b/IGC/Compiler/HandleFRemInstructions.cpp
index 6b48f0b28..8025667f1 100644
--- a/IGC/Compiler/HandleFRemInstructions.cpp
+++ b/IGC/Compiler/HandleFRemInstructions.cpp
@@ -12,6 +12,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/Instructions.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Transforms/Utils/BasicBlockUtils.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/IGCPassSupport.h"
 #include "Probe/Assertion.h"
@@ -61,7 +62,7 @@ void HandleFRemInstructions::visitFRem(llvm::BinaryOperator& I)
 
     if (ValType->isVectorTy())
     {
-        auto VecCount = cast<VectorType>(ValType)->getNumElements();
+        auto VecCount = cast<IGCLLVM::FixedVectorType>(ValType)->getNumElements();
         if (VecCount == 2 || VecCount == 3 || VecCount == 4 || VecCount == 8 || VecCount == 16)
         {
             VecStr = "v" + std::to_string(VecCount);
diff --git a/IGC/Compiler/HandleLoadStoreInstructions.cpp b/IGC/Compiler/HandleLoadStoreInstructions.cpp
index 40e9930b5..8c2e60018 100644
--- a/IGC/Compiler/HandleLoadStoreInstructions.cpp
+++ b/IGC/Compiler/HandleLoadStoreInstructions.cpp
@@ -61,7 +61,7 @@ void HandleLoadStoreInstructions::visitLoadInst(llvm::LoadInst& I)
 
         if (I.getType()->isVectorTy())
         {
-            numVectorElements = (uint32_t)cast<VectorType>(I.getType())->getNumElements();
+            numVectorElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
             doubleDstType = IGCLLVM::FixedVectorType::get(builder.getDoubleTy(), numVectorElements);
         }
         uint as = ptrv->getType()->getPointerAddressSpace();
@@ -134,7 +134,7 @@ void HandleLoadStoreInstructions::visitStoreInst(llvm::StoreInst& I)
 
         if (I.getValueOperand()->getType()->isVectorTy())
         {
-            numVectorElements = (uint32_t)cast<VectorType>(I.getValueOperand()->getType())->getNumElements();
+            numVectorElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(I.getValueOperand()->getType())->getNumElements();
         }
 
 
diff --git a/IGC/Compiler/LegalizationPass.cpp b/IGC/Compiler/LegalizationPass.cpp
index bc03b251d..aa63e2b92 100644
--- a/IGC/Compiler/LegalizationPass.cpp
+++ b/IGC/Compiler/LegalizationPass.cpp
@@ -671,7 +671,7 @@ void Legalization::visitBitCastInst(llvm::BitCastInst& I)
         if (!isa<TruncInst>(pZ->getOperand(0)))
             return;
 
-        auto* pVecTy = cast<VectorType>(pZ->getDestTy());
+        auto* pVecTy = cast<IGCLLVM::FixedVectorType>(pZ->getDestTy());
         if (pVecTy->getNumElements() != 3)
             return;
 
@@ -766,7 +766,7 @@ void Legalization::visitSelectInst(SelectInst& I)
     }
     else if (I.getType()->isVectorTy())
     {
-        unsigned int vecSize = (unsigned)cast<VectorType>(I.getType())->getNumElements();
+        unsigned int vecSize = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
         Value* newVec = UndefValue::get(I.getType());
         m_builder->SetInsertPoint(&I);
         for (unsigned int i = 0; i < vecSize; i++)
@@ -1148,7 +1148,7 @@ void Legalization::visitStoreInst(StoreInst& I)
     if (ConstantDataVector * vec = dyn_cast<ConstantDataVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementAsConstant(i);
@@ -1168,7 +1168,7 @@ void Legalization::visitStoreInst(StoreInst& I)
     else if (ConstantVector * vec = dyn_cast<ConstantVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getOperand(i);
@@ -1188,7 +1188,7 @@ void Legalization::visitStoreInst(StoreInst& I)
     else if (ConstantAggregateZero * vec = dyn_cast<ConstantAggregateZero>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementValue(i);
@@ -1338,7 +1338,7 @@ void Legalization::visitInsertElementInst(InsertElementInst& I)
     if (ConstantDataVector * vec = dyn_cast<ConstantDataVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementAsConstant(i);
@@ -1358,7 +1358,7 @@ void Legalization::visitInsertElementInst(InsertElementInst& I)
     else if (ConstantVector * vec = dyn_cast<ConstantVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(I.getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getOperand(i);
@@ -1378,7 +1378,7 @@ void Legalization::visitInsertElementInst(InsertElementInst& I)
     else if (ConstantAggregateZero * vec = dyn_cast<ConstantAggregateZero>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(I.getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementValue(i);
@@ -1395,7 +1395,7 @@ void Legalization::visitInsertElementInst(InsertElementInst& I)
     else if (I.getOperand(1)->getType()->isIntegerTy(1))
     {
         // This promotes i1 insertelement to i32
-        unsigned int nbElement = (unsigned)cast<VectorType>(I.getOperand(0)->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getOperand(0)->getType())->getNumElements();
         Value* newVec = UndefValue::get(IGCLLVM::FixedVectorType::get(m_builder->getInt32Ty(), nbElement));
         PromoteInsertElement(&I, newVec);
     }
@@ -1408,7 +1408,7 @@ void Legalization::visitShuffleVectorInst(ShuffleVectorInst& I)
     // If the original vector is a constant, just use the scalar constant,
     // otherwise extract from the original vector.
 
-    VectorType* resType = cast<VectorType>(I.getType());
+    IGCLLVM::FixedVectorType* resType = cast<IGCLLVM::FixedVectorType>(I.getType());
     Value* newVec = UndefValue::get(resType);
     Value* src0 = I.getOperand(0);
     Value* src1 = I.getOperand(1);
@@ -1419,7 +1419,7 @@ void Legalization::visitShuffleVectorInst(ShuffleVectorInst& I)
     Constant* mask = I.getShuffleMaskForBitcode();
 #endif
     // The two inputs are guaranteed to be of the same type
-    VectorType* inType = cast<VectorType>(src0->getType());
+    IGCLLVM::FixedVectorType* inType = cast<IGCLLVM::FixedVectorType>(src0->getType());
     int inCount = int_cast<int>(inType->getNumElements());
     int inBase = 2;  // 2 means using undef
     // if inType == resType, use src0/src1 as the input
@@ -1635,7 +1635,7 @@ Type* Legalization::LegalAllocaType(Type* type) const
 #endif
         legalType = IGCLLVM::FixedVectorType::get(
             LegalAllocaType(cast<VectorType>(type)->getElementType()),
-            (unsigned)cast<VectorType>(type)->getNumElements());
+            (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements());
         break;
     case Type::StructTyID:
         return LegalStructAllocaType(type);
@@ -1976,7 +1976,7 @@ void Legalization::visitIntrinsicInst(llvm::IntrinsicInst& I)
         Value* newValue = nullptr;
         if (srcType->isVectorTy())
         {
-            auto sourceVT = cast<VectorType>(srcType);
+            auto sourceVT = cast<IGCLLVM::FixedVectorType>(srcType);
             const unsigned int numElements = (uint32_t)sourceVT->getNumElements();
             Value* dstVec = UndefValue::get(srcType);
             for (unsigned int i = 0; i < numElements; ++i)
@@ -2119,7 +2119,7 @@ void Legalization::visitTruncInst(llvm::TruncInst& I) {
     }
 
     Src = BC->getOperand(0);
-    VectorType* VTy = dyn_cast<VectorType>(Src->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Src->getType());
     // Bail out if it's not bitcasted from <3 x i16>
     if (!VTy || VTy->getNumElements() != 3 || !VTy->getElementType()->isIntegerTy(16))
         return;
diff --git a/IGC/Compiler/Legalizer/InstPromoter.cpp b/IGC/Compiler/Legalizer/InstPromoter.cpp
index 56c0b9981..6d1778b61 100644
--- a/IGC/Compiler/Legalizer/InstPromoter.cpp
+++ b/IGC/Compiler/Legalizer/InstPromoter.cpp
@@ -382,7 +382,7 @@ bool InstPromoter::visitBitCastInst(BitCastInst& I) {
             IRB->CreateBitCast(Val, IGCLLVM::FixedVectorType::get(DestTy->getScalarType(), N));
 
         std::vector<Constant*> Vals;
-        for (unsigned i = 0; i < (unsigned)cast<VectorType>(DestTy)->getNumElements(); i++)
+        for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(DestTy)->getNumElements(); i++)
             Vals.push_back(IRB->getInt32(i));
 
         Value* Mask = ConstantVector::get(Vals);
diff --git a/IGC/Compiler/Legalizer/InstScalarizer.cpp b/IGC/Compiler/Legalizer/InstScalarizer.cpp
index c2b3f7ba7..2e519eef0 100644
--- a/IGC/Compiler/Legalizer/InstScalarizer.cpp
+++ b/IGC/Compiler/Legalizer/InstScalarizer.cpp
@@ -114,7 +114,7 @@ bool InstScalarizer::visitLoadInst(LoadInst& I) {
         // otherwise, it's broken.
         IGC_ASSERT(TL->getTypeSizeInBits(EltTy) == TL->getTypeStoreSizeInBits(EltTy));
 
-        unsigned NumElts = (unsigned)cast<VectorType>(OrigTy)->getNumElements();
+        unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(OrigTy)->getNumElements();
         unsigned Elt = 0;
 
         Type* NewPtrTy = PointerType::get(EltTy, AS);
@@ -252,7 +252,7 @@ bool InstScalarizer::visitStoreInst(StoreInst& I) {
         // otherwise, it's broken.
         IGC_ASSERT(TL->getTypeSizeInBits(EltTy) == TL->getTypeStoreSizeInBits(EltTy));
 
-        unsigned NumElts = (unsigned)cast<VectorType>(OrigTy)->getNumElements();
+        unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(OrigTy)->getNumElements();
         unsigned Elt = 0;
 
         Type* NewPtrTy = PointerType::get(EltTy, AS);
@@ -482,7 +482,7 @@ bool InstScalarizer::visitInsertElementInst(InsertElementInst& I) {
     IGC_ASSERT(EltSeq->size());
     IGC_ASSERT(VecSeqCopy.size() % EltSeq->size() == 0);
 
-    unsigned NumElts = (unsigned)cast<VectorType>(I.getOperand(0)->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getOperand(0)->getType())->getNumElements();
     unsigned i = 0;
     for (unsigned Elt = 0; Elt != NumElts; ++Elt) {
         if (Elt == Idx) {
diff --git a/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp b/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp
index 5257de424..7d93665dc 100644
--- a/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp
+++ b/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp
@@ -146,7 +146,7 @@ void PeepholeTypeLegalizer::legalizePhiInstruction(Instruction& I)
 
     if (quotient > 1)
     {
-        unsigned numElements = I.getType()->isVectorTy() ? (unsigned)cast<VectorType>(I.getType())->getNumElements() : 1;
+        unsigned numElements = I.getType()->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements() : 1;
         Type* newType = IGCLLVM::FixedVectorType::get(Type::getIntNTy(I.getContext(), promoteToInt), quotient * numElements);
 
         PHINode* newPhi = m_builder->CreatePHI(newType, oldPhi->getNumIncomingValues());
@@ -207,7 +207,7 @@ void PeepholeTypeLegalizer::legalizeExtractElement(Instruction& I)
     unsigned elementWidth = extract->getType()->getScalarSizeInBits();
     if (!isLegalInteger(elementWidth) && extract->getType()->isIntOrIntVectorTy())
     {
-        unsigned numElements = (unsigned)cast<VectorType>(extract->getOperand(0)->getType())->getNumElements();
+        unsigned numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(extract->getOperand(0)->getType())->getNumElements();
         unsigned quotient, promoteToInt;
         promoteInt(elementWidth, quotient, promoteToInt, DL->getLargestLegalIntTypeSizeInBits());
 
@@ -834,7 +834,7 @@ void PeepholeTypeLegalizer::cleanupZExtInst(Instruction& I) {
         }
 
         unsigned ipElmtSize = prevInst->getOperand(0)->getType()->getScalarSizeInBits();
-        unsigned ipVecSize = (unsigned)cast<VectorType>(prevInst->getOperand(0)->getType())->getNumElements();
+        unsigned ipVecSize = (unsigned)cast<IGCLLVM::FixedVectorType>(prevInst->getOperand(0)->getType())->getNumElements();
         unsigned convFactor = promoteToInt / ipElmtSize;
 
         Value* vecRes = UndefValue::get(IGCLLVM::FixedVectorType::get(llvm::Type::getIntNTy(I.getContext(), promoteToInt), quotient));
diff --git a/IGC/Compiler/Legalizer/TypeLegalizer.cpp b/IGC/Compiler/Legalizer/TypeLegalizer.cpp
index 6dfdae07e..03f866f14 100644
--- a/IGC/Compiler/Legalizer/TypeLegalizer.cpp
+++ b/IGC/Compiler/Legalizer/TypeLegalizer.cpp
@@ -16,6 +16,7 @@ SPDX-License-Identifier: MIT
 #include "InstScalarizer.h"
 #include "InstElementizer.h"
 #include "common/LLVMWarningsPush.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/ADT/PostOrderIterator.h"
 #include "llvm/IR/CFG.h"
 #include "llvm/Support/Debug.h"
@@ -274,7 +275,7 @@ TypeSeq* TypeLegalizer::getScalarizedTypeSeq(Type* Ty) {
     }
 
     Type* EltTy = cast<VectorType>(Ty)->getElementType();
-    for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i)
+    for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i)
         TMI->second.push_back(EltTy);
 
     return &TMI->second;
diff --git a/IGC/Compiler/Legalizer/TypeLegalizer.h b/IGC/Compiler/Legalizer/TypeLegalizer.h
index b51f00ac7..ee6d41992 100644
--- a/IGC/Compiler/Legalizer/TypeLegalizer.h
+++ b/IGC/Compiler/Legalizer/TypeLegalizer.h
@@ -12,6 +12,7 @@ SPDX-License-Identifier: MIT
 #include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/Analysis/InlineCost.h"
 #include "llvmWrapper/IR/InstrTypes.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/Support/Alignment.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/DenseMap.h"
@@ -271,7 +272,7 @@ namespace IGC {
                 if (!Ty->isVectorTy())
                     return false;
 
-                unsigned NumElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+                unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
                 Type* EltTy = cast<VectorType>(Ty)->getElementType();
                 const auto& ProfitLengths = getProfitLoadVectorLength(EltTy);
 
diff --git a/IGC/Compiler/LowPrecisionOptPass.cpp b/IGC/Compiler/LowPrecisionOptPass.cpp
index b7a1474f4..e3d65bc18 100644
--- a/IGC/Compiler/LowPrecisionOptPass.cpp
+++ b/IGC/Compiler/LowPrecisionOptPass.cpp
@@ -253,7 +253,7 @@ bool LowPrecisionOpt::propagateSamplerType(llvm::GenIntrinsicInst& I)
 
     if (I.getType()->isVectorTy())
     {
-        numberOfElements = int_cast<unsigned int>(cast<VectorType>(I.getType())->getNumElements());
+        numberOfElements = int_cast<unsigned int>(cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements());
     }
 
     llvm::SmallVector<llvm::Type*, 4> overloadTys;
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.cpp
index b22e14bd5..a2b5927ea 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.cpp
@@ -7,6 +7,7 @@ SPDX-License-Identifier: MIT
 ============================= end_copyright_notice ===========================*/
 
 #include "llvm/Config/llvm-config.h"
+#include <llvm/Analysis/TargetLibraryInfo.h>
 #include "Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.h"
 #include "Compiler/CodeGenPublic.h"
 #include "Compiler/IGCPassSupport.h"
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp
index 0edacda24..7c0e7936d 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp
@@ -8,6 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.hpp"
 #include "Compiler/IGCPassSupport.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/IR/Function.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -114,7 +115,7 @@ static uint64_t getNumElements(Type* type)
     {
         return arrayType->getNumElements();
     }
-    if (VectorType * vectorType = dyn_cast<VectorType>(type))
+    if (IGCLLVM::FixedVectorType * vectorType = dyn_cast<IGCLLVM::FixedVectorType>(type))
     {
         return vectorType->getNumElements();
     }
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp
index 68b188d0b..ecc1b648a 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp
@@ -11,6 +11,7 @@ SPDX-License-Identifier: MIT
 #include "Compiler/IGCPassSupport.h"
 #include "GenISAIntrinsics/GenIntrinsicInst.h"
 
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/IR/Function.h>
 #include <llvm/IR/Instructions.h>
@@ -117,7 +118,7 @@ Value* CorrectlyRoundedDivSqrt::emitIEEEDivide(BinaryOperator* I, Value* Op0, Va
     }
     else
     {
-        auto vType = dyn_cast<VectorType>(Ty);
+        auto vType = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         unsigned VecLen = (uint32_t)vType->getNumElements();
         Divide = UndefValue::get(Ty);
         for (unsigned i = 0; i < VecLen; i++)
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
index 387350066..86673d224 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
@@ -937,7 +937,7 @@ namespace //Anonymous
         {
             auto ndrangeStructName = "struct.ndrange_t";
             auto module = _deviceExecCall->getModule();
-            auto ndrangeTy = module->getTypeByName(ndrangeStructName);
+            auto ndrangeTy = IGCLLVM::getTypeByName(module, ndrangeStructName);
             if (ndrangeTy == nullptr)
             {
                 //create struct type
@@ -1682,7 +1682,7 @@ namespace //Anonymous
                     // this generates <element_type><num_elements> string. Ie for char2 element_type is char and num_elements is 2
                     // that is done by callin BaseTypeName on vector element type, this recursive call has only a depth of one since
                     // there are no compound vectors in OpenCL.
-                    auto vType = llvm::dyn_cast<VectorType>(type);
+                    auto vType = llvm::dyn_cast<IGCLLVM::FixedVectorType>(type);
                     return BaseTypeName(type->getContainedType(0), os) << vType->getNumElements();
                 }
                 default:
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp
index 4a7ce70b4..0178f4652 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp
@@ -8,6 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "Compiler/Optimizer/OpenCLPasses/KernelArgs.hpp"
 #include "AdaptorCommon/ImplicitArgs.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/IR/Argument.h>
 #include <llvm/IR/DataLayout.h>
@@ -372,7 +373,7 @@ unsigned int KernelArg::calcAssociatedArgNo(const ImplicitArg& implicitArg, cons
 
 unsigned int KernelArg::getNumComponents() const
 {
-    if (VectorType * vecType = dyn_cast<VectorType>(m_arg->getType()))
+    if (IGCLLVM::FixedVectorType * vecType = dyn_cast<IGCLLVM::FixedVectorType>(m_arg->getType()))
     {
         // Vector
         return int_cast<unsigned int>(vecType->getNumElements());
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
index 92c534a10..711fb6b01 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
@@ -723,7 +723,7 @@ Value* OpenCLPrintfResolution::fixupPrintfArg(CallInst& printfCall, Value* arg,
             }
 
             Type* newType = Type::getFloatTy(arg->getContext());
-            if (auto argVT = dyn_cast<VectorType>(arg->getType()))
+            if (auto argVT = dyn_cast<IGCLLVM::FixedVectorType>(arg->getType()))
             {
                 newType = IGCLLVM::FixedVectorType::get(newType, (unsigned)argVT->getNumElements());
             }
@@ -753,7 +753,7 @@ void OpenCLPrintfResolution::preprocessPrintfArgs(CallInst& printfCall)
         IGC::SHADER_PRINTF_TYPE argDataType = getPrintfArgDataType(arg);
         arg = fixupPrintfArg(printfCall, arg, argDataType);
         uint vecSize = 0;
-        if (auto argVType = dyn_cast<VectorType>(argType)) {
+        if (auto argVType = dyn_cast<IGCLLVM::FixedVectorType>(argType)) {
             vecSize = (uint)argVType->getNumElements();
         }
         m_argDescriptors.push_back(SPrintfArgDescriptor(argDataType, arg, vecSize));
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp
index ac14b2d04..48c7e8637 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp
@@ -618,7 +618,7 @@ public:
             Type* scalarptrTy = PointerType::get(scalarType, pLoad->getPointerAddressSpace());
             IGC_ASSERT(scalarType->getPrimitiveSizeInBits() / 8 == elementSize);
             Value* vec = UndefValue::get(pLoad->getType());
-            auto pLoadVT = cast<VectorType>(pLoad->getType());
+            auto pLoadVT = cast<IGCLLVM::FixedVectorType>(pLoad->getType());
             for (unsigned i = 0, e = (unsigned)pLoadVT->getNumElements(); i < e; ++i)
             {
                 Value* ptr = IRB.CreateIntToPtr(address, scalarptrTy);
@@ -657,7 +657,7 @@ public:
             IGC_ASSERT(scalarType->getPrimitiveSizeInBits() / 8 == elementSize);
             Value* vec = pStore->getValueOperand();
 
-            unsigned vecNumElts = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+            unsigned vecNumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
             for (unsigned i = 0; i < vecNumElts; ++i)
             {
                 Value* ptr = IRB.CreateIntToPtr(address, scalarptrTy);
@@ -728,7 +728,7 @@ bool PrivateMemoryResolution::testTransposedMemory(const Type* pTmpType, const T
         }
         else if(pTmpType->isVectorTy())
         {
-            auto pTmpVType = cast<VectorType>(pTmpType);
+            auto pTmpVType = cast<IGCLLVM::FixedVectorType>(pTmpType);
             tmpAllocaSize *= pTmpVType->getNumElements();
             pTmpType = pTmpType->getContainedType(0);
             ok = (nullptr != pTmpType);
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
index 88707c588..ae9c7e671 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
@@ -244,7 +244,7 @@ Instruction* ReplaceUnsupportedIntrinsics::insertLoop(Instruction* Loc, Value* L
 Value* ReplaceUnsupportedIntrinsics::replicateScalar(
     Value* ScalarVal, Type* Ty, Instruction* InsertBefore)
 {
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* ETy = VTy ? VTy->getElementType() : Ty;
     uint32_t sBits = (unsigned int)ScalarVal->getType()->getPrimitiveSizeInBits();
     uint32_t nBits = (unsigned int)ETy->getPrimitiveSizeInBits();
@@ -905,7 +905,7 @@ void ReplaceUnsupportedIntrinsics::replaceFunnelShift(IntrinsicInst* I) {
     }
 
     Value* numBits = Builder.getIntN(sizeInBits, sizeInBits);
-    if (auto IVT = dyn_cast<VectorType>(I->getType())) {
+    if (auto IVT = dyn_cast<IGCLLVM::FixedVectorType>(I->getType())) {
         numBits = ConstantVector::getSplat(IGCLLVM::getElementCount((uint32_t)IVT->getNumElements()), cast<Constant>(numBits));
     }
     auto shiftModulo = Builder.CreateURem(I->getArgOperand(2), numBits);
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
index a8e24680c..4de05effa 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
@@ -279,7 +279,7 @@ static Value* BuildLoadInst(CallInst& CI, unsigned int Offset, Type* DataType)
     auto Size = ElemByteSize;
     if (auto DataVecType = dyn_cast<VectorType>(DataType))
     {
-        Size *= (unsigned int)DataVecType->getNumElements();
+        Size *= cast<IGCLLVM::FixedVectorType>(DataType)->getNumElements();
     }
     unsigned int AlignedOffset = (Offset / ElemByteSize) * ElemByteSize;
     unsigned int LoadByteSize = (Offset == AlignedOffset) ? Size : Size * 2;
diff --git a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
index 248ab1039..423beef7b 100644
--- a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
@@ -339,7 +339,7 @@ bool PreCompiledFuncImport::preProcessDouble()
                     }
                     else
                     {
-                        uint32_t vectorSize = cast<VectorType>(Inst->getType())->getNumElements();
+                        uint32_t vectorSize = cast<IGCLLVM::FixedVectorType>(Inst->getType())->getNumElements();
                         fsub = llvm::UndefValue::get(Inst->getType());
 
                         for (uint32_t i = 0; i < vectorSize; ++i)
@@ -1002,7 +1002,7 @@ void PreCompiledFuncImport::processDivide(BinaryOperator& inst, EmulatedFunction
 
     Type* argumentType = inst.getOperand(0)->getType();
 
-    if (auto argumentVType = dyn_cast<VectorType>(argumentType))
+    if (auto argumentVType = dyn_cast<IGCLLVM::FixedVectorType>(argumentType))
     {
         numElements = (unsigned)argumentVType->getNumElements();
     }
diff --git a/IGC/Compiler/Optimizer/Scalarizer.cpp b/IGC/Compiler/Optimizer/Scalarizer.cpp
index 740fb4d57..b98ba6693 100644
--- a/IGC/Compiler/Optimizer/Scalarizer.cpp
+++ b/IGC/Compiler/Optimizer/Scalarizer.cpp
@@ -403,7 +403,7 @@ void ScalarizeFunction::scalarizeInstruction(BinaryOperator* BI)
 {
     V_PRINT(scalarizer, "\t\tBinary instruction\n");
     IGC_ASSERT_MESSAGE(BI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(BI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(BI->getType());
     // Only need handling for vector binary ops
     if (!instType) return;
 
@@ -463,7 +463,7 @@ void ScalarizeFunction::scalarizeInstruction(CmpInst* CI)
 {
     V_PRINT(scalarizer, "\t\tCompare instruction\n");
     IGC_ASSERT_MESSAGE(CI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(CI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getType());
     // Only need handling for vector compares
     if (!instType) return;
 
@@ -511,13 +511,13 @@ void ScalarizeFunction::scalarizeInstruction(CastInst* CI)
 {
     V_PRINT(scalarizer, "\t\tCast instruction\n");
     IGC_ASSERT_MESSAGE(CI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(CI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getType());
 
     // For BitCast - we only scalarize if src and dst types have same vector length
     if (isa<BitCastInst>(CI))
     {
         if (!instType) return recoverNonScalarizableInst(CI);
-        VectorType* srcType = dyn_cast<VectorType>(CI->getOperand(0)->getType());
+        IGCLLVM::FixedVectorType* srcType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getOperand(0)->getType());
         if (!srcType || (instType->getNumElements() != srcType->getNumElements()))
         {
             return recoverNonScalarizableInst(CI);
@@ -572,7 +572,7 @@ void ScalarizeFunction::scalarizeInstruction(PHINode* PI)
 {
     V_PRINT(scalarizer, "\t\tPHI instruction\n");
     IGC_ASSERT_MESSAGE(PI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(PI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(PI->getType());
     // Only need handling for vector PHI
     if (!instType) return;
 
@@ -683,7 +683,7 @@ void ScalarizeFunction::scalarizeInstruction(SelectInst* SI)
 {
     V_PRINT(scalarizer, "\t\tSelect instruction\n");
     IGC_ASSERT_MESSAGE(SI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(SI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(SI->getType());
     // Only need handling for vector select
     if (!instType) return;
 
@@ -765,7 +765,7 @@ void ScalarizeFunction::scalarizeInstruction(ExtractElementInst* EI)
 
     // Connect the "extracted" value to all its consumers
     uint64_t scalarIndex = cast<ConstantInt>(scalarIndexVal)->getZExtValue();
-    auto valueVType = cast<VectorType>(vectorValue->getType());
+    auto valueVType = cast<IGCLLVM::FixedVectorType>(vectorValue->getType());
     if (static_cast<unsigned int>(scalarIndex) < (unsigned)valueVType->getNumElements())
     {
         IGC_ASSERT_MESSAGE(NULL != operand[static_cast<unsigned int>(scalarIndex)], "SCM error");
@@ -829,7 +829,7 @@ void ScalarizeFunction::scalarizeInstruction(InsertElementInst* II)
     if (isa<UndefValue>(sourceVectorValue))
     {
         // Scalarize the undef value (generate a scalar undef)
-        VectorType* inputVectorType = dyn_cast<VectorType>(sourceVectorValue->getType());
+        IGCLLVM::FixedVectorType* inputVectorType = dyn_cast<IGCLLVM::FixedVectorType>(sourceVectorValue->getType());
         IGC_ASSERT_MESSAGE(inputVectorType, "expected vector argument");
 
         UndefValue* undefVal = UndefValue::get(inputVectorType->getElementType());
@@ -870,7 +870,7 @@ void ScalarizeFunction::scalarizeInstruction(ShuffleVectorInst* SI)
     IGC_ASSERT(nullptr != sourceVector0Value);
     Value* sourceVector1Value = SI->getOperand(1);
     IGC_ASSERT(nullptr != sourceVector1Value);
-    VectorType* const inputType = dyn_cast<VectorType>(sourceVector0Value->getType());
+    IGCLLVM::FixedVectorType* const inputType = dyn_cast<IGCLLVM::FixedVectorType>(sourceVector0Value->getType());
     IGC_ASSERT_MESSAGE(nullptr != inputType, "vector input error");
     IGC_ASSERT_MESSAGE(inputType == sourceVector1Value->getType(), "vector input error");
     unsigned sourceVectorWidth = int_cast<unsigned>(inputType->getNumElements());
@@ -892,7 +892,7 @@ void ScalarizeFunction::scalarizeInstruction(ShuffleVectorInst* SI)
 
     // Generate array for shuffled scalar values
     SmallVector<Value*, MAX_INPUT_VECTOR_WIDTH>newVector;
-    unsigned width = int_cast<unsigned>(SI->getType()->getNumElements());
+    unsigned width = int_cast<unsigned>(cast<IGCLLVM::FixedVectorType>(SI->getType())->getNumElements());
 
     // Generate undef value, which may be needed as some scalar elements
     UndefValue* undef = UndefValue::get(inputType->getElementType());
@@ -961,7 +961,7 @@ void ScalarizeFunction::scalarizeInstruction(GetElementPtrInst* GI)
 
     if (baseValue->getType()->isVectorTy())
     {
-        width = int_cast<unsigned>(dyn_cast<VectorType>(baseValue->getType())->getNumElements());
+        width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(baseValue->getType())->getNumElements());
         // Obtain the scalarized operands
         obtainScalarizedValues(operand1, NULL, baseValue, GI);
         ptrTy = dyn_cast<VectorType>(baseValue->getType())->getElementType();
@@ -972,7 +972,7 @@ void ScalarizeFunction::scalarizeInstruction(GetElementPtrInst* GI)
     }
     if (indexValue->getType()->isVectorTy())
     {
-        width = int_cast<unsigned>(dyn_cast<VectorType>(indexValue->getType())->getNumElements());
+        width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(indexValue->getType())->getNumElements());
         // Obtain the scalarized operands
         obtainScalarizedValues(operand2, NULL, indexValue, GI);
     }
@@ -1011,7 +1011,7 @@ void ScalarizeFunction::obtainScalarizedValues(SmallVectorImpl<Value*>& retValue
 {
     V_PRINT(scalarizer, "\t\t\tObtaining scalar value... " << *origValue << "\n");
 
-    VectorType* origType = dyn_cast<VectorType>(origValue->getType());
+    IGCLLVM::FixedVectorType* origType = dyn_cast<IGCLLVM::FixedVectorType>(origValue->getType());
     IGC_ASSERT_MESSAGE(origType, "Value must have a vector type!");
     unsigned width = int_cast<unsigned>(origType->getNumElements());
 
@@ -1170,7 +1170,7 @@ void ScalarizeFunction::obtainVectorValueWhichMightBeScalarizedImpl(Value* vecto
     }
 
     Value* assembledVector = UndefValue::get(vectorVal->getType());
-    unsigned width = int_cast<unsigned>(dyn_cast<VectorType>(vectorVal->getType())->getNumElements());
+    unsigned width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(vectorVal->getType())->getNumElements());
     for (unsigned i = 0; i < width; i++)
     {
         IGC_ASSERT_MESSAGE(NULL != valueEntry->scalarValues[i], "SCM entry has NULL value");
@@ -1230,7 +1230,7 @@ void ScalarizeFunction::updateSCMEntryWithValues(ScalarizeFunction::SCMEntry* en
     bool matchDbgLoc)
 {
     IGC_ASSERT_MESSAGE((origValue->getType()->isArrayTy() || origValue->getType()->isVectorTy()), "only Vector values are supported");
-    unsigned width = int_cast<unsigned>(dyn_cast<VectorType>(origValue->getType())->getNumElements());
+    unsigned width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(origValue->getType())->getNumElements());
 
     entry->isOriginalVectorRemoved = isOrigValueRemoved;
 
@@ -1301,7 +1301,7 @@ void ScalarizeFunction::resolveDeferredInstructions()
         Instruction* vectorInst = dyn_cast<Instruction>(current.unresolvedInst);
         IGC_ASSERT_MESSAGE(vectorInst, "DRL only handles unresolved instructions");
 
-        VectorType* currType = dyn_cast<VectorType>(vectorInst->getType());
+        IGCLLVM::FixedVectorType* currType = dyn_cast<IGCLLVM::FixedVectorType>(vectorInst->getType());
         IGC_ASSERT_MESSAGE(currType, "Cannot have DRL of non-vector value");
         unsigned width = int_cast<unsigned>(currType->getNumElements());
 
diff --git a/IGC/Compiler/Optimizer/ValueTracker.cpp b/IGC/Compiler/Optimizer/ValueTracker.cpp
index a2796daa5..a3d03d267 100644
--- a/IGC/Compiler/Optimizer/ValueTracker.cpp
+++ b/IGC/Compiler/Optimizer/ValueTracker.cpp
@@ -162,7 +162,7 @@ Value* ValueTracker::handleExtractElement(ExtractElementInst* E)
         {
             auto mask = I->getShuffleMask();
             uint shuffleidx = int_cast<uint>(mask[(uint)idx]);
-            auto vType = dyn_cast<VectorType>(I->getOperand(0)->getType());
+            auto vType = dyn_cast<IGCLLVM::FixedVectorType>(I->getOperand(0)->getType());
             baseValue = (shuffleidx < vType->getNumElements()) ?
                 I->getOperand(0) : I->getOperand(1);
         }
diff --git a/IGC/Compiler/VerificationPass.cpp b/IGC/Compiler/VerificationPass.cpp
index 7a9d69bec..df73419c0 100644
--- a/IGC/Compiler/VerificationPass.cpp
+++ b/IGC/Compiler/VerificationPass.cpp
@@ -286,7 +286,7 @@ bool VerificationPass::verifyType(Type* type, Value* val)
 
     case IGCLLVM::VectorTyID:
     {
-        auto VType = cast<VectorType>(type);
+        auto VType = cast<IGCLLVM::FixedVectorType>(type);
         unsigned typeSize = (unsigned)VType->getNumElements();
         if (!m_IGC_IR_spec.vectorTypeSizes.count(typeSize))
         {
diff --git a/IGC/DebugInfo/DebugInfoUtils.hpp b/IGC/DebugInfo/DebugInfoUtils.hpp
index 28b7fcf73..d16d79a3d 100644
--- a/IGC/DebugInfo/DebugInfoUtils.hpp
+++ b/IGC/DebugInfo/DebugInfoUtils.hpp
@@ -92,7 +92,7 @@ namespace IGC
                 IGCLLVM::DIBuilder Builder(M);
                 llvm::DIGlobalVariable* GV = GVs[j]->getVariable();
                 llvm::DIScope* scopeToUse = GV->getScope();
-                llvm::DILocation* locToUse = llvm::DebugLoc::get(GV->getLine(), 0, scopeToUse, loc);
+                llvm::DILocation* locToUse = llvm::DILocation::get(scopeToUse->getContext(), GV->getLine(), 0, scopeToUse, loc);
                 if (llvm::isa<llvm::DICompileUnit>(GV->getScope()))
                 {
                     // Function has no DebugLoc so it is either internal
diff --git a/IGC/DebugInfo/DwarfDebug.cpp b/IGC/DebugInfo/DwarfDebug.cpp
index 027a3a530..f57dd72cb 100644
--- a/IGC/DebugInfo/DwarfDebug.cpp
+++ b/IGC/DebugInfo/DwarfDebug.cpp
@@ -1993,9 +1993,9 @@ static DebugLoc getFnDebugLoc(DebugLoc DL, const LLVMContext& Ctx)
         // Check for number of operands since the compatibility is cheap here.
         if (SP->getNumOperands() > 19)
         {
-            return DebugLoc::get(SP->getScopeLine(), 0, SP);
+            return DILocation::get(SP->getContext(), SP->getScopeLine(), 0, SP);
         }
-        return DebugLoc::get(SP->getLine(), 0, SP);
+        return DILocation::get(SP->getContext(), SP->getLine(), 0, SP);
     }
 
     return DebugLoc();
diff --git a/IGC/GenISAIntrinsics/GenIntrinsics.cpp b/IGC/GenISAIntrinsics/GenIntrinsics.cpp
index a6d6f0ae6..c48271125 100644
--- a/IGC/GenISAIntrinsics/GenIntrinsics.cpp
+++ b/IGC/GenISAIntrinsics/GenIntrinsics.cpp
@@ -188,7 +188,7 @@ static Type *DecodeFixedType(ArrayRef<GenISAIntrinsic::IITDescriptor> &Infos,
   case IITDescriptor::SameVecWidthArgument: {
     Type *EltTy = DecodeFixedType(Infos, Tys, Context);
     Type *Ty = Tys[D.getArgumentNumber()];
-    if (VectorType *VTy = dyn_cast<VectorType>(Ty)) {
+    if (IGCLLVM::FixedVectorType *VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty)) {
       return IGCLLVM::FixedVectorType::get(EltTy, int_cast<unsigned int>(VTy->getNumElements()));
     }
     IGC_ASSERT_EXIT_MESSAGE(0, "unhandled");
@@ -199,7 +199,7 @@ static Type *DecodeFixedType(ArrayRef<GenISAIntrinsic::IITDescriptor> &Infos,
   }
   case IITDescriptor::VecOfPtrsToElt: {
       Type *Ty = Tys[D.getArgumentNumber()];
-      VectorType *VTy = dyn_cast<VectorType>(Ty);
+      IGCLLVM::FixedVectorType *VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
       if (!VTy)
           IGC_ASSERT_EXIT_MESSAGE(0, "Expected an argument of Vector Type");
       Type *EltTy = cast<VectorType>(VTy)->getElementType();
@@ -418,7 +418,7 @@ static std::string getMangledTypeStr(Type* Ty) {
     Result += "f";
   }
   else if (isa<VectorType>(Ty))
-    Result += "v" + utostr(cast<VectorType>(Ty)->getNumElements()) +
+    Result += "v" + utostr(cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements()) +
       getMangledTypeStr(cast<VectorType>(Ty)->getElementType());
   else if (Ty)
     Result += EVT::getEVT(Ty).getEVTString();
diff --git a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
index 2306c2357..b5f66f048 100644
--- a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
+++ b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
@@ -4993,7 +4993,7 @@ void LLVM3DBuilder<preserveNames, T, Inserter>::VectorToScalars(
     IGC_ASSERT(nullptr != vector->getType());
     IGC_ASSERT(vector->getType()->isVectorTy());
 
-    const unsigned count = (unsigned)llvm::cast<llvm::VectorType>(vector->getType())->getNumElements();
+    const unsigned count = (unsigned)llvm::cast<IGCLLVM::FixedVectorType>(vector->getType())->getNumElements();
     IGC_ASSERT(1 < count);
     IGC_ASSERT(count <= 4);
     IGC_ASSERT(count <= maxSize);
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/DerivedTypes.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/DerivedTypes.h
index a207f5d44..117dae814 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/DerivedTypes.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/DerivedTypes.h
@@ -11,6 +11,7 @@ SPDX-License-Identifier: MIT
 
 #include "llvm/Config/llvm-config.h"
 #include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/Module.h"
 
 namespace IGCLLVM
 {
@@ -44,6 +45,15 @@ namespace IGCLLVM
         return false;
 #endif
     }
+
+    inline llvm::StructType *getTypeByName(llvm::Module *M, llvm::StringRef Name) {
+#if LLVM_VERSION_MAJOR >= 12
+        return llvm::StructType::getTypeByName(M->getContext(), Name);
+#else
+        return M->getTypeByName(Name);
+#endif
+    }
+
 }
 
 #endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h b/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h
index 19c5183eb..709f1bbbb 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h
@@ -17,10 +17,14 @@ using namespace llvm;
 namespace IGCLLVM {
 #if LLVM_VERSION_MAJOR < 11
 inline unsigned getElementCount(unsigned EC) { return EC; }
-#else
+#elif LLVM_VERSION_MAJOR == 11
 inline ElementCount getElementCount(unsigned EC) {
   return ElementCount(EC, false);
 }
+#else
+inline ElementCount getElementCount(unsigned EC) {
+  return ElementCount::get(EC, false);
+}
 #endif
 } // namespace IGCLLVM
 
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
index 74841ddc1..1df041372 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
@@ -26,7 +26,7 @@ namespace IGCLLVM
     {
         return llvm::createLoopUnrollPass(OptLevel, false, Threshold, Count, AllowPartial, Runtime, UpperBound, AllowPeeling);
     }
-#elif LLVM_VERSION_MAJOR == 9 || LLVM_VERSION_MAJOR == 10 || LLVM_VERSION_MAJOR == 11
+#elif LLVM_VERSION_MAJOR >= 9 && LLVM_VERSION_MAJOR <= 12
     inline static llvm::Pass * createLoopUnrollPass(
         int OptLevel = 2, int Threshold = -1, int Count = -1,
         int AllowPartial = -1, int Runtime = -1,
@@ -34,7 +34,7 @@ namespace IGCLLVM
     {
         return llvm::createLoopUnrollPass(OptLevel, false, false, Threshold, Count, AllowPartial, Runtime, UpperBound, AllowPeeling);
     }
-#elif LLVM_VERSION_MAJOR >= 12
+#else
     //DO NOT assume same function signature for all incoming llvm versions! Double check to upgrade!
 #error Not supported llvm version.
 #endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Utils/LoopUtils.h b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Utils/LoopUtils.h
index 8cf0adf24..33d5b7c35 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Utils/LoopUtils.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Utils/LoopUtils.h
@@ -23,6 +23,14 @@ namespace IGCLLVM
         return llvm::InsertPreheaderForLoop(L, DT, LI, nullptr, PreserveLCSSA);
     }
 #endif
+
+    inline bool isInnermost(llvm::Loop *L) {
+#if LLVM_VERSION_MAJOR >= 12
+        return L->isInnermost();
+#else
+        return L->empty();
+#endif
+    }
 }
 
 #endif
diff --git a/IGC/common/igc_resourceDimTypes.h b/IGC/common/igc_resourceDimTypes.h
index a9a6a1871..713d6f4bb 100644
--- a/IGC/common/igc_resourceDimTypes.h
+++ b/IGC/common/igc_resourceDimTypes.h
@@ -50,6 +50,10 @@ namespace IGC
             resourceDimTypeId == DIM_2D_TYPE || resourceDimTypeId == DIM_2D_ARRAY_TYPE ||
             resourceDimTypeId == DIM_3D_TYPE || resourceDimTypeId == DIM_CUBE_TYPE || resourceDimTypeId == DIM_CUBE_ARRAY_TYPE));
 
+#if LLVM_VERSION_MAJOR >= 12
+        return llvm::StructType::getTypeByName(module.getContext(), ResourceDimensionTypeName[resourceDimTypeId]);
+#else
         return module.getTypeByName(ResourceDimensionTypeName[resourceDimTypeId]);
+#endif
     }
-}
\ No newline at end of file
+}
-- 
2.20.1

