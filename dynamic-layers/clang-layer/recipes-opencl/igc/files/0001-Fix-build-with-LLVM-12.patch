From 869cdb784aa062bd08bd26465bf0b5651e8f112e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Zolt=C3=A1n=20B=C3=B6sz=C3=B6rm=C3=A9nyi?= <zboszor@pr.hu>
Date: Thu, 25 Feb 2021 10:39:27 +0100
Subject: [PATCH 1/3] Fix build with LLVM 12
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Upstream-Status: Pending

Signed-off-by: Zoltán Böszörményi <zboszor@gmail.com>
Signed-off-by: Naveen Saini <naveen.kumar.saini@intel.com>
---
 .../LegalizeFunctionSignatures.cpp            |  2 +-
 IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp          | 26 +++++++++-----
 IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp            |  6 +++-
 IGC/Compiler/CISACodeGen/AdvMemOpt.cpp        |  4 +++
 IGC/Compiler/CISACodeGen/CShader.cpp          | 14 ++++----
 .../CISACodeGen/ConstantCoalescing.cpp        | 14 ++++----
 IGC/Compiler/CISACodeGen/DeSSA.cpp            |  3 +-
 IGC/Compiler/CISACodeGen/EmitVISAPass.cpp     | 35 +++++++++---------
 IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp     |  4 +--
 IGC/Compiler/CISACodeGen/GenIRLowering.cpp    |  4 +--
 .../CISACodeGen/GenSimplification.cpp         |  5 +--
 .../CISACodeGen/GeometryShaderLowering.cpp    |  3 +-
 IGC/Compiler/CISACodeGen/LdShrink.cpp         | 10 ++++--
 .../CISACodeGen/LowerGEPForPrivMem.cpp        |  8 ++---
 IGC/Compiler/CISACodeGen/MemOpt.cpp           |  8 ++---
 IGC/Compiler/CISACodeGen/MemOpt2.cpp          |  5 +--
 .../CISACodeGen/OpenCLKernelCodeGen.cpp       |  2 +-
 IGC/Compiler/CISACodeGen/PatternMatchPass.cpp |  4 +--
 IGC/Compiler/CISACodeGen/PushAnalysis.cpp     |  4 +--
 .../CISACodeGen/RegisterEstimator.cpp         |  3 +-
 .../CISACodeGen/RegisterPressureEstimate.hpp  |  3 +-
 IGC/Compiler/CISACodeGen/SLMConstProp.cpp     |  3 +-
 .../CISACodeGen/ScalarizerCodeGen.cpp         |  4 +--
 IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp    |  4 +++
 .../CISACodeGen/Simd32Profitability.cpp       | 11 ++++--
 IGC/Compiler/CISACodeGen/SimplifyConstant.cpp | 12 +++----
 IGC/Compiler/CISACodeGen/TypeDemote.cpp       |  3 +-
 .../CISACodeGen/VariableReuseAnalysis.cpp     |  5 +--
 .../CISACodeGen/VariableReuseAnalysis.hpp     |  3 +-
 IGC/Compiler/CISACodeGen/VectorPreProcess.cpp | 24 ++++++-------
 IGC/Compiler/CISACodeGen/VectorProcess.cpp    |  4 +--
 IGC/Compiler/CISACodeGen/helper.cpp           | 10 +++---
 IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp    | 15 ++++++--
 IGC/Compiler/CustomSafeOptPass.cpp            | 26 +++++++-------
 IGC/Compiler/DebugInfo/ScalarVISAModule.cpp   |  3 +-
 IGC/Compiler/GenTTI.cpp                       |  8 ++++-
 IGC/Compiler/GenUpdateCB.cpp                  |  3 +-
 IGC/Compiler/HandleFRemInstructions.cpp       |  3 +-
 IGC/Compiler/HandleLoadStoreInstructions.cpp  |  4 +--
 IGC/Compiler/LegalizationPass.cpp             | 28 +++++++--------
 IGC/Compiler/Legalizer/InstPromoter.cpp       | 11 ++++--
 IGC/Compiler/Legalizer/InstScalarizer.cpp     |  6 ++--
 .../Legalizer/PeepholeTypeLegalizer.cpp       |  6 ++--
 IGC/Compiler/Legalizer/TypeLegalizer.cpp      |  3 +-
 IGC/Compiler/Legalizer/TypeLegalizer.h        |  3 +-
 IGC/Compiler/LowPrecisionOptPass.cpp          |  2 +-
 .../AddressSpaceAliasAnalysis.cpp             |  9 ++---
 .../AggregateArguments/AggregateArguments.cpp |  3 +-
 .../CorrectlyRoundedDivSqrt.cpp               |  3 +-
 .../DeviceEnqueueFuncs/TransformBlocks.cpp    |  6 +++-
 .../Optimizer/OpenCLPasses/KernelArgs.cpp     |  3 +-
 .../OpenCLPrintf/OpenCLPrintfResolution.cpp   |  4 +--
 .../PrivateMemory/PrivateMemoryResolution.cpp | 11 ++++--
 .../ReplaceUnsupportedIntrinsics.cpp          |  4 +--
 .../OpenCLPasses/WIFuncs/WIFuncResolution.cpp |  4 +++
 .../Optimizer/PreCompiledFuncImport.cpp       |  4 +--
 IGC/Compiler/Optimizer/Scalarizer.cpp         | 36 +++++++++----------
 IGC/Compiler/Optimizer/ValueTracker.cpp       |  2 +-
 IGC/Compiler/VerificationPass.cpp             |  2 +-
 IGC/DebugInfo/DebugInfoUtils.hpp              |  4 +++
 IGC/DebugInfo/DwarfDebug.cpp                  |  8 +++++
 IGC/GenISAIntrinsics/GenIntrinsics.cpp        |  6 ++--
 .../BuiltinsFrontendDefinitions.hpp           |  2 +-
 .../include/llvmWrapper/Support/TypeSize.h    |  8 ++++-
 .../include/llvmWrapper/Transforms/Scalar.h   |  4 +--
 IGC/common/igc_resourceDimTypes.h             |  5 +++
 66 files changed, 303 insertions(+), 196 deletions(-)

diff --git a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
index 4046b4a6..8ed36089 100644
--- a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
+++ b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
@@ -156,7 +156,7 @@ inline Type* LegalizedIntVectorType(Module& M, const Type* const oldTy)
     else if (size <= 64) newSize = 64;
     else IGC_ASSERT_MESSAGE(0, "Currently don't support upscaling int sizes > 64 bits");
 
-    return IGCLLVM::FixedVectorType::get(IntegerType::get(M.getContext(), newSize), (unsigned)cast<VectorType>(oldTy)->getNumElements());
+    return IGCLLVM::FixedVectorType::get(IntegerType::get(M.getContext(), newSize), (unsigned)cast<IGCLLVM::FixedVectorType>(oldTy)->getNumElements());
 }
 
 void LegalizeFunctionSignatures::FixFunctionSignatures()
diff --git a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
index 41d1f2ea..725a1512 100644
--- a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
@@ -1576,7 +1576,11 @@ void SPIRVToLLVMDbgTran::transDbgInfo(SPIRVValue *SV, Value *V) {
             Line->getColumn(), scope, iat);
 
         if(scope && !isa<DIFile>(scope))
+#if LLVM_VERSION_MAJOR >= 12
+            I->setDebugLoc(DILocation::get(scope->getContext(), Line->getLine(), Line->getColumn(),
+#else
             I->setDebugLoc(DebugLoc::get(Line->getLine(), Line->getColumn(),
+#endif
                 scope, iat));
     }
 }
@@ -1925,7 +1929,11 @@ SPIRVToLLVM::transType(SPIRVType *T) {
         auto name = isSubgroupAvcINTELTypeOpCode(OC) ?
             OCLSubgroupINTELTypeOpCodeMap::rmap(OC) :
             BuiltinOpaqueGenericTypeOpCodeMap::rmap(OC);
+#if LLVM_VERSION_MAJOR >= 12
+        auto *pST = llvm::StructType::getTypeByName(M->getContext(), name);
+#else
         auto *pST = M->getTypeByName(name);
+#endif
         pST = pST ? pST : StructType::create(*Context, name);
 
         return mapType(T, PointerType::get(pST, getOCLOpaqueTypeAddrSpace(OC)));
@@ -2403,7 +2411,7 @@ Value *SPIRVToLLVM::promoteBool(Value *pVal, BasicBlock *BB)
 
     auto *PromoType = isa<VectorType>(pVal->getType()) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt8Ty(pVal->getContext()),
-        (unsigned)cast<VectorType>(pVal->getType())->getNumElements())) :
+        (unsigned)cast<IGCLLVM::FixedVectorType>(pVal->getType())->getNumElements())) :
         Type::getInt8Ty(pVal->getContext());
 
     if (auto *C = dyn_cast<Constant>(pVal))
@@ -2445,7 +2453,7 @@ Value *SPIRVToLLVM::truncBool(Value *pVal, BasicBlock *BB)
 
     auto *TruncType = isa<VectorType>(pVal->getType()) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt1Ty(pVal->getContext()),
-            (unsigned)cast<VectorType>(pVal->getType())->getNumElements())) :
+            (unsigned)cast<IGCLLVM::FixedVectorType>(pVal->getType())->getNumElements())) :
         Type::getInt1Ty(pVal->getContext());
 
     if (auto *C = dyn_cast<Constant>(pVal))
@@ -2491,7 +2499,7 @@ Type *SPIRVToLLVM::truncBoolType(SPIRVType *SPVType, Type *LLType)
 
     return isa<VectorType>(LLType) ?
         cast<Type>(IGCLLVM::FixedVectorType::get(Type::getInt1Ty(LLType->getContext()),
-                                   (unsigned)cast<VectorType>(LLType)->getNumElements())) :
+                                   (unsigned)cast<IGCLLVM::FixedVectorType>(LLType)->getNumElements())) :
         Type::getInt1Ty(LLType->getContext());
 }
 
@@ -2648,7 +2656,7 @@ SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *BV, Function *F,
       {
         if(CV[i]->getType()->isVectorTy())
         {
-          for(uint32_t j = 0; j < cast<VectorType>(CV[i]->getType())->getNumElements(); j++)
+          for(uint32_t j = 0; j < cast<IGCLLVM::FixedVectorType>(CV[i]->getType())->getNumElements(); j++)
           {
             Value *v = ExtractElementInst::Create( CV[i],ConstantInt::get( *Context,APInt( 32,j ) ),BCC->getName(),BB );
             elm1 = CreateCompositeConstruct( elm1,v,pos++ );
@@ -3336,7 +3344,7 @@ SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *BV, Function *F,
       auto Vector = transValue(BI->getOperand(0), F, BB);
       auto Scalar = transValue(BI->getOperand(1), F, BB);
 
-      auto VecType = cast<VectorType>(Vector->getType());
+      auto VecType = cast<IGCLLVM::FixedVectorType>(Vector->getType());
       auto Undef   = UndefValue::get(VecType);
 
       auto ScalarVec = InsertElementInst::Create(Undef, Scalar,
@@ -3361,7 +3369,7 @@ SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *BV, Function *F,
           a->getType()->getScalarSizeInBits() - 1);
       auto *ShiftOp = isa<VectorType>(a->getType()) ?
           ConstantVector::getSplat(
-              IGCLLVM::getElementCount((unsigned)cast<VectorType>(a->getType())->getNumElements()), ShiftAmt) :
+              IGCLLVM::getElementCount((unsigned)cast<IGCLLVM::FixedVectorType>(a->getType())->getNumElements()), ShiftAmt) :
           ShiftAmt;
 
       // OCL C:
@@ -3705,15 +3713,15 @@ SPIRVToLLVM::transSPIRVBuiltinFromInst(SPIRVInstruction *BI, BasicBlock *BB) {
               "",
               BB);
       }
-      else if (cast<VectorType>(coordType)->getNumElements() != 4)
+      else if (cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements() != 4)
       {
           Value *undef = UndefValue::get(coordType);
 
           SmallVector<Constant*, 4> shuffleIdx;
-          for (unsigned i = 0; i < cast<VectorType>(coordType)->getNumElements(); i++)
+          for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements(); i++)
               shuffleIdx.push_back(ConstantInt::get(Type::getInt32Ty(*Context), i));
 
-          for (uint64_t i = (unsigned)cast<VectorType>(coordType)->getNumElements(); i < 4; i++)
+          for (uint64_t i = (unsigned)cast<IGCLLVM::FixedVectorType>(coordType)->getNumElements(); i < 4; i++)
               shuffleIdx.push_back(ConstantInt::get(Type::getInt32Ty(*Context), 0));
 
           imageCoordinateWiden = new ShuffleVectorInst(
diff --git a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
index 57821556..91b4623c 100644
--- a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
@@ -93,7 +93,11 @@ saveLLVMModule(Module *M, const std::string &OutputFile) {
 PointerType*
 getOrCreateOpaquePtrType(Module *M, const std::string &Name,
     unsigned AddrSpace) {
+#if LLVM_VERSION_MAJOR >= 12
+  auto OpaqueType = llvm::StructType::getTypeByName(M->getContext(), Name);
+#else
   auto OpaqueType = M->getTypeByName(Name);
+#endif
   if (!OpaqueType)
     OpaqueType = StructType::create(M->getContext(), Name);
   return PointerType::get(OpaqueType, AddrSpace);
@@ -159,7 +163,7 @@ std::string recursive_mangle(const Type* pType)
             return "i" + utostr(pType->getIntegerBitWidth());
         case IGCLLVM::VectorTyID:
         {
-            unsigned vecLen = (unsigned)cast<VectorType>(pType)->getNumElements();
+            unsigned vecLen = (unsigned)cast<IGCLLVM::FixedVectorType>(pType)->getNumElements();
             Type* pEltType = cast<VectorType>(pType)->getElementType();
             return "v" + utostr(vecLen) + recursive_mangle(pEltType);
         }
diff --git a/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp b/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp
index 81acc6ce..fc45a510 100644
--- a/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp
+++ b/IGC/Compiler/CISACodeGen/AdvMemOpt.cpp
@@ -134,7 +134,11 @@ bool AdvMemOpt::runOnFunction(Function& F) {
     for (auto I = LI->begin(), E = LI->end(); I != E; ++I)
         for (auto DFI = df_begin(*I), DFE = df_end(*I); DFI != DFE; ++DFI) {
             Loop* L = *DFI;
+#if LLVM_VERSION_MAJOR >= 12
+            if (L->isInnermost())
+#else
             if (L->empty())
+#endif
                 InnermostLoops.push_back(L);
         }
 
diff --git a/IGC/Compiler/CISACodeGen/CShader.cpp b/IGC/Compiler/CISACodeGen/CShader.cpp
index e3cb8153..ebc99615 100644
--- a/IGC/Compiler/CISACodeGen/CShader.cpp
+++ b/IGC/Compiler/CISACodeGen/CShader.cpp
@@ -430,7 +430,7 @@ void CShader::CreateAliasVars()
                         continue;
 
                     Type* Ty = V->getType();
-                    VectorType* VTy = dyn_cast<VectorType>(Ty);
+                    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
                     Type* BTy = VTy ? VTy->getElementType() : Ty;
                     int nelts = (VTy ? (int)VTy->getNumElements() : 1);
 
@@ -961,7 +961,7 @@ bool CShader::InsideDivergentCF(llvm::Instruction* inst)
 uint CShader::GetNbVectorElementAndMask(llvm::Value* val, uint32_t& mask)
 {
     llvm::Type* type = val->getType();
-    uint nbElement = int_cast<uint>(cast<VectorType>(type)->getNumElements());
+    uint nbElement = int_cast<uint>(cast<IGCLLVM::FixedVectorType>(type)->getNumElements());
     mask = 0;
     // we don't process vector bigger than 31 elements as the mask has only 32bits
     // If we want to support longer vectors we need to extend the mask size
@@ -1166,7 +1166,7 @@ uint32_t CShader::GetExtractMask(llvm::Value* vecVal)
     {
         return it->second;
     }
-    const unsigned int numChannels = vecVal->getType()->isVectorTy() ? (unsigned)cast<VectorType>(vecVal->getType())->getNumElements() : 1;
+    const unsigned int numChannels = vecVal->getType()->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(vecVal->getType())->getNumElements() : 1;
     IGC_ASSERT_MESSAGE(numChannels <= 32, "Mask has 32 bits maximally!");
     return (1ULL << numChannels) - 1;
 }
@@ -1174,7 +1174,7 @@ uint32_t CShader::GetExtractMask(llvm::Value* vecVal)
 uint16_t CShader::AdjustExtractIndex(llvm::Value* vecVal, uint16_t index)
 {
     uint16_t result = index;
-    if (cast<VectorType>(vecVal->getType())->getNumElements() < 32)
+    if (cast<IGCLLVM::FixedVectorType>(vecVal->getType())->getNumElements() < 32)
     {
         uint32_t mask = GetExtractMask(vecVal);
         for (uint i = 0; i < index; ++i)
@@ -1591,7 +1591,7 @@ auto sizeToSIMDMode = [](uint32_t size)
 
 CVariable* CShader::GetConstant(llvm::Constant* C, CVariable* dstVar)
 {
-    llvm::VectorType* VTy = llvm::dyn_cast<llvm::VectorType>(C->getType());
+    IGCLLVM::FixedVectorType* VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(C->getType());
     if (C && VTy)
     {   // Vector constant
         llvm::Type* eTy = VTy->getElementType();
@@ -1816,7 +1816,7 @@ uint32_t CShader::GetNumElts(llvm::Type* type, bool isUniform)
     {
         IGC_ASSERT(type->getContainedType(0)->isIntegerTy() || type->getContainedType(0)->isFloatingPointTy());
 
-        auto VT = cast<VectorType>(type);
+        auto VT = cast<IGCLLVM::FixedVectorType>(type);
         numElts *= (uint16_t)VT->getNumElements();
     }
     return numElts;
@@ -2516,7 +2516,7 @@ CVariable* CShader::GetSymbol(llvm::Value* value, bool fromConstantPool)
                 if (isVecType)
                 {
                     // Map the entire vector value to the CVar
-                    unsigned numElements = (unsigned)cast<VectorType>(value->getType())->getNumElements();
+                    unsigned numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(value->getType())->getNumElements();
                     var = GetNewVariable(numElements, ISA_TYPE_UQ, (GetContext()->platform.getGRFSize() == 64) ? EALIGN_32WORD : EALIGN_HWORD, true, 1, valName);
                     symbolMapping.insert(std::pair<llvm::Value*, CVariable*>(value, var));
 
diff --git a/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp b/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp
index 1efe116f..47b7c6c0 100644
--- a/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp
+++ b/IGC/Compiler/CISACodeGen/ConstantCoalescing.cpp
@@ -224,7 +224,7 @@ static void checkInsertExtractMatch(InsertElementInst* insertInst, Value* base,
 
 static bool canReplaceInsert(InsertElementInst* insertElt)
 {
-    VectorType* VTy = cast<VectorType>(insertElt->getOperand(0)->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(insertElt->getOperand(0)->getType());
     ConstantInt* index = dyn_cast<ConstantInt>(insertElt->getOperand(2));
     if (!index || index->getZExtValue() != VTy->getNumElements() - 1)
     {
@@ -312,7 +312,7 @@ void ConstantCoalescing::VectorizePrep(llvm::BasicBlock* bb)
         {
             if (load->getType()->isVectorTy() && wiAns->isUniform(load))
             {
-                srcNElts = (uint32_t)cast<VectorType>(load->getType())->getNumElements();
+                srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(load->getType())->getNumElements();
                 DenseMap<uint64_t, Instruction*> extractElementMap;
 
                 for (auto iter = load->user_begin(); iter != load->user_end(); iter++)
@@ -396,7 +396,7 @@ bool ConstantCoalescing::isProfitableLoad(
             (isa<LoadInst>(I) && wiAns->isUniform(I)) ?
             16 : 4;
 
-        if (cast<VectorType>(LoadTy)->getNumElements() > MaxVectorInput)
+        if (cast<IGCLLVM::FixedVectorType>(LoadTy)->getNumElements() > MaxVectorInput)
             return false;
 
         MaxEltPlus = CheckVectorElementUses(I);
@@ -1787,7 +1787,7 @@ void ConstantCoalescing::AdjustChunk(BufChunk* cov_chunk, uint start_adj, uint s
         WIAnalysis::WIDependancy loadDep = wiAns->whichDepend(cov_chunk->chunkIO);
         irBuilder->SetInsertPoint(cov_chunk->chunkIO->getNextNode());
         Value* vec = UndefValue::get(originalType);
-        for (unsigned i = 0; i < cast<VectorType>(originalType)->getNumElements(); i++)
+        for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(originalType)->getNumElements(); i++)
         {
             Value* channel = irBuilder->CreateExtractElement(
                 cov_chunk->chunkIO, irBuilder->getInt32(i + start_adj));
@@ -1851,7 +1851,7 @@ void ConstantCoalescing::MoveExtracts(BufChunk* cov_chunk, Instruction* load, ui
             irBuilder->SetInsertPoint(load->getNextNode());
             Type* vecType = load->getType();
             Value* vec = UndefValue::get(vecType);
-            for (unsigned i = 0; i < cast<VectorType>(vecType)->getNumElements(); i++)
+            for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(vecType)->getNumElements(); i++)
             {
                 Value* channel = irBuilder->CreateExtractElement(
                     cov_chunk->chunkIO, irBuilder->getInt32(i + start_adj));
@@ -1915,7 +1915,7 @@ void ConstantCoalescing::EnlargeChunk(BufChunk* cov_chunk, uint size_adj)
         WIAnalysis::WIDependancy loadDep = wiAns->whichDepend(cov_chunk->chunkIO);
         irBuilder->SetInsertPoint(cov_chunk->chunkIO->getNextNode());
         Value* vec = UndefValue::get(originalType);
-        for (unsigned i = 0; i < cast<VectorType>(originalType)->getNumElements(); i++)
+        for (unsigned i = 0; i < cast<IGCLLVM::FixedVectorType>(originalType)->getNumElements(); i++)
         {
             Value* channel = irBuilder->CreateExtractElement(
                 cov_chunk->chunkIO, irBuilder->getInt32(i));
@@ -2343,7 +2343,7 @@ void ConstantCoalescing::ReplaceLoadWithSamplerLoad(
         if (dstTy->isVectorTy())
         {
             result = UndefValue::get(dstTy);
-            for (uint i = 0; i < cast<VectorType>(dstTy)->getNumElements(); i++)
+            for (uint i = 0; i < cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements(); i++)
             {
                 Value* tmpData = ExtractFromSamplerData(cast<VectorType>(dstTy)->getElementType(), i);
                 result = irBuilder->CreateInsertElement(result, tmpData, irBuilder->getInt32(i));
diff --git a/IGC/Compiler/CISACodeGen/DeSSA.cpp b/IGC/Compiler/CISACodeGen/DeSSA.cpp
index f540dc11..6fab0246 100644
--- a/IGC/Compiler/CISACodeGen/DeSSA.cpp
+++ b/IGC/Compiler/CISACodeGen/DeSSA.cpp
@@ -83,6 +83,7 @@ IN THE SOFTWARE.
 #include "Compiler/IGCPassSupport.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/IR/InstIterator.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include <algorithm>
 #include "Probe/Assertion.h"
@@ -1284,7 +1285,7 @@ int DeSSA::checkInsertElementAlias(
     //
     // If found, return the actual vector size;
     // otherwise, return 0.
-    VectorType* VTy = cast<VectorType>(IEI->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(IEI->getType());
     IGC_ASSERT(nullptr != VTy);
     int nelts = (int)VTy->getNumElements();
     AllIEIs.resize(nelts, nullptr);
diff --git a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
index 3ab1cc5f..4502ef62 100644
--- a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
+++ b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
@@ -53,6 +53,7 @@ IN THE SOFTWARE.
 #include "Compiler/IGCPassSupport.h"
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/IR/Instructions.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/Support/Path.h"
 #include "llvmWrapper/IR/Intrinsics.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -1165,7 +1166,7 @@ bool EmitPass::canRelocatePhiMov(
                 if (dst != src)
                 {
                     int numElt = 1;
-                    if (VectorType * vTy = dyn_cast<VectorType>(PN->getType()))
+                    if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(PN->getType()))
                     {
                         numElt = int_cast<int>(vTy->getNumElements());
                     }
@@ -1302,7 +1303,7 @@ void EmitPass::MovPhiSources(llvm::BasicBlock* aBB)
                         phiSrcDstList.push_back(phiInfo);
 
                         int numElt = 0;
-                        if (VectorType * vTy = dyn_cast<VectorType>(PN->getType()))
+                        if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(PN->getType()))
                         {
                             numElt = int_cast<int>(vTy->getNumElements());
                         }
@@ -5375,7 +5376,7 @@ void EmitPass::emitLegacySimdBlockWrite(llvm::Instruction* inst, llvm::Value* pt
     bool useA64 = isA64Ptr(ptrType, m_currShader->GetContext());
 
     Type* Ty = dataPtr->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t nbElements = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
 
     uint32_t typeSizeInBytes = Ty->getScalarSizeInBits() / 8;
@@ -5621,7 +5622,7 @@ void EmitPass::emitLegacySimdBlockRead(llvm::Instruction* inst, llvm::Value* ptr
     bool useA64 = isA64Ptr(ptrType, m_currShader->GetContext());
 
     Type* Ty = inst->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t nbElements = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
 
     uint32_t typeSizeInBytes = Ty->getScalarSizeInBits() / 8;
@@ -5913,7 +5914,7 @@ void EmitPass::emitMediaBlockIO(const llvm::GenIntrinsicInst* inst, bool isRead)
         };
 
         uint nElts = isa<VectorType>(pDataType) ?
-            (uint)cast<VectorType>(pDataType)->getNumElements() :
+            (uint)cast<IGCLLVM::FixedVectorType>(pDataType)->getNumElements() :
             1;
 
         // Now, do the copies.
@@ -6003,7 +6004,7 @@ void EmitPass::emitSimdMediaBlockRead(llvm::Instruction* inst)
     uint32_t nbElements = 1;
     if (inst->getType()->isVectorTy())
     {
-        nbElements = (uint32_t)cast<VectorType>(inst->getType())->getNumElements();
+        nbElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
     }
     IGC_ASSERT_MESSAGE(nbElements <= 8, "InValid Vector Size");
 
@@ -6247,7 +6248,7 @@ void EmitPass::emitSimdMediaBlockWrite(llvm::Instruction* inst)
     uint32_t nbElements = 1;
     if (dataPtr->getType()->isVectorTy())
     {
-        nbElements = (uint32_t)cast<VectorType>(dataPtr->getType())->getNumElements();
+        nbElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(dataPtr->getType())->getNumElements();
     }
     IGC_ASSERT_MESSAGE(nbElements <= 8, "InValid Vector Size");
 
@@ -8993,8 +8994,8 @@ void EmitPass::emitBitCast(llvm::BitCastInst* btCst)
 {
     Type* srcType = btCst->getOperand(0)->getType();
     Type* dstType = btCst->getType();
-    unsigned int numSrcElement = srcType->isVectorTy() ? (unsigned)cast<VectorType>(srcType)->getNumElements() : 1;
-    unsigned int numDstElement = dstType->isVectorTy() ? (unsigned)cast<VectorType>(dstType)->getNumElements() : 1;
+    unsigned int numSrcElement = srcType->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(srcType)->getNumElements() : 1;
+    unsigned int numDstElement = dstType->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(dstType)->getNumElements() : 1;
 
     if (srcType->isPointerTy())
     {
@@ -9468,7 +9469,7 @@ void EmitPass::emitLoad3DInner(LdRawIntrinsic* inst, ResourceDescriptor& resourc
     {
         IGC_ASSERT_MESSAGE(predDefSurface != ESURFACE_STATELESS, "scratch cannot be uniform");
         Type* loadType = inst->getType();
-        uint numElement = loadType->isVectorTy() ? (uint)cast<VectorType>(loadType)->getNumElements() : 1;
+        uint numElement = loadType->isVectorTy() ? (uint)cast<IGCLLVM::FixedVectorType>(loadType)->getNumElements() : 1;
         if (predDefSurface == ESURFACE_SLM)
         {
             IGC_ASSERT(numElement <= 4);
@@ -10795,7 +10796,7 @@ void EmitPass::emitInsert(llvm::Instruction* inst)
             pVecVar = GetSymbol(pVec);
             if (pVecVar != pInstVar)
             {
-                emitVectorCopy(pInstVar, pVecVar, int_cast<unsigned>(dyn_cast<VectorType>(pVecType)->getNumElements()));
+                emitVectorCopy(pInstVar, pVecVar, int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(pVecType)->getNumElements()));
             }
         }
     }
@@ -14596,7 +14597,7 @@ bool EmitPass::isUniformStoreOCL(llvm::StoreInst* SI)
 
     Value* storeVal = SI->getValueOperand();
     Type* Ty = storeVal->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     uint32_t elts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
 
@@ -14626,7 +14627,7 @@ void EmitPass::emitVectorBitCast(llvm::BitCastInst* BCI)
     if (srcTy->isVectorTy())
     {
         srcEltTy = cast<VectorType>(srcTy)->getElementType();
-        srcNElts = (uint32_t)cast<VectorType>(srcTy)->getNumElements();
+        srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(srcTy)->getNumElements();
     }
     else
     {
@@ -14636,7 +14637,7 @@ void EmitPass::emitVectorBitCast(llvm::BitCastInst* BCI)
     if (dstTy->isVectorTy())
     {
         dstEltTy = cast<VectorType>(dstTy)->getElementType();
-        dstNElts = (uint32_t)cast<VectorType>(dstTy)->getNumElements();
+        dstNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements();
     }
     else
     {
@@ -15215,7 +15216,7 @@ void EmitPass::emitVectorLoad(LoadInst* inst, Value* offset, ConstantInt* immOff
     }
 
     Type* Ty = inst->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
     uint32_t eltBytes = GetScalarTypeSizeInRegister(eltTy);
     IGC_ASSERT_MESSAGE((eltBytes == 1) || (eltBytes == 2) || (eltBytes == 4) || (eltBytes == 8),
@@ -15667,7 +15668,7 @@ void EmitPass::emitVectorStore(StoreInst* inst, Value* offset, ConstantInt* immO
 
     Value* storedVal = inst->getValueOperand();
     Type* Ty = storedVal->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* eltTy = VTy ? VTy->getElementType() : Ty;
     uint32_t eltBytes = GetScalarTypeSizeInRegister(eltTy);
 
@@ -16471,7 +16472,7 @@ void EmitPass::emitCopyAll(CVariable* Dst, CVariable* Src, llvm::Type* Ty)
     }
     else if (Ty->isVectorTy())
     {
-        unsigned NElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+        unsigned NElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
         emitVectorCopy(Dst, Src, NElts);
     }
     else
diff --git a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
index 28248f30..767b477a 100644
--- a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
+++ b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
@@ -1961,7 +1961,7 @@ bool InstExpander::visitExtractElement(ExtractElementInst& EEI) {
     // later.
 
     Value* V = EEI.getVectorOperand();
-    unsigned NumElts = (unsigned)cast<VectorType>(V->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(V->getType())->getNumElements();
     V = IRB->CreateBitCast(V, Emu->getV2Int32Ty(NumElts));
     // Re-calculate indices to Lo and Hi parts.
     Value* Idx = EEI.getIndexOperand();
@@ -1998,7 +1998,7 @@ bool InstExpander::visitInsertElement(InsertElementInst& IEI) {
 
     // Create the emulated vector.
     Value* NewVal = IEI.getOperand(0);
-    unsigned NumElts = (unsigned)cast<VectorType>(NewVal->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(NewVal->getType())->getNumElements();
     NewVal = IRB->CreateBitCast(NewVal, Emu->getV2Int32Ty(NumElts));
     // Re-calculate indices to Lo and Hi parts.
     Value* Idx = IEI.getOperand(2);
diff --git a/IGC/Compiler/CISACodeGen/GenIRLowering.cpp b/IGC/Compiler/CISACodeGen/GenIRLowering.cpp
index c74a2ac6..78e8a4aa 100644
--- a/IGC/Compiler/CISACodeGen/GenIRLowering.cpp
+++ b/IGC/Compiler/CISACodeGen/GenIRLowering.cpp
@@ -453,7 +453,7 @@ Value* GEPLowering::getSExtOrTrunc(Value* Val, Type* NewTy) const {
 
     IGC_ASSERT_MESSAGE(OldTy->isIntOrIntVectorTy(), "Index should be Integer or vector of Integer!");
 
-    if (auto OldVecTy = dyn_cast<VectorType>(OldTy)) {
+    if (auto OldVecTy = dyn_cast<IGCLLVM::FixedVectorType>(OldTy)) {
         OldWidth = (unsigned)OldVecTy->getNumElements() * OldVecTy->getElementType()->getIntegerBitWidth();
         NewWidth = (unsigned)OldVecTy->getNumElements() * NewTy->getIntegerBitWidth();
     }
@@ -805,7 +805,7 @@ bool GEPLowering::lowerGetElementPtrInst(GetElementPtrInst* GEP) const
                 }
                 else
                 {
-                    if (auto NewIdxVT = dyn_cast<VectorType>(NewIdx->getType())) {
+                    if (auto NewIdxVT = dyn_cast<IGCLLVM::FixedVectorType>(NewIdx->getType())) {
                         Value* result = llvm::UndefValue::get(FixedVectorType::get(PtrMathTy, (unsigned)NewIdxVT->getNumElements()));
                         for (uint32_t j = 0; j < (uint32_t)NewIdxVT->getNumElements(); j++) {
                             result = Builder->CreateInsertElement(result, PointerValue, Builder->getInt32(j));
diff --git a/IGC/Compiler/CISACodeGen/GenSimplification.cpp b/IGC/Compiler/CISACodeGen/GenSimplification.cpp
index 8c38f229..f432061e 100644
--- a/IGC/Compiler/CISACodeGen/GenSimplification.cpp
+++ b/IGC/Compiler/CISACodeGen/GenSimplification.cpp
@@ -35,6 +35,7 @@ IN THE SOFTWARE.
 #include <llvm/IR/InstVisitor.h>
 #include <llvm/IR/Instruction.h>
 #include <llvm/Support/raw_ostream.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
 
@@ -164,7 +165,7 @@ bool GenSimplification::simplifyVectorPHINodeCase2(PHINode& PN) const {
 
     Type* Ty = PN.getType();
     Type* EltTy = Ty->getScalarType();
-    unsigned NumElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
 
     SmallVector<Value*, 8> Lanes;
     SmallVector<SmallVector<Value*, 8>, 4> Values;
@@ -238,7 +239,7 @@ void GenSimplification::visitPHINode(PHINode& PN) {
 void GenSimplification::visitExtractElement(ExtractElementInst& EEI) {
     // Skip non-2-element vector.
     Value* Vec = EEI.getVectorOperand();
-    VectorType* VTy = cast<VectorType>(Vec->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(Vec->getType());
     if (VTy->getNumElements() != 2)
         return;
 
diff --git a/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp b/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp
index e00e8469..a60b9892 100644
--- a/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp
+++ b/IGC/Compiler/CISACodeGen/GeometryShaderLowering.cpp
@@ -33,6 +33,7 @@ IN THE SOFTWARE.
 #include <llvm/IR/PassManager.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/Verifier.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/InitializePasses.h"
 #include "Probe/Assertion.h"
@@ -507,7 +508,7 @@ void GeometryShaderLowering::AddURBRead(
     {
         Value* vec = UndefValue::get(inst->getType());
         IRBuilder<> builder(inst);
-        for (unsigned int i = 0; i < cast<VectorType>(inst->getType())->getNumElements(); i++)
+        for (unsigned int i = 0; i < cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements(); i++)
         {
             Value* vecElement = builder.CreateExtractElement(urbRead, builder.getInt32(i));
             vec = builder.CreateInsertElement(vec, vecElement, builder.getInt32(i));
diff --git a/IGC/Compiler/CISACodeGen/LdShrink.cpp b/IGC/Compiler/CISACodeGen/LdShrink.cpp
index d89fbd0e..2df06df2 100644
--- a/IGC/Compiler/CISACodeGen/LdShrink.cpp
+++ b/IGC/Compiler/CISACodeGen/LdShrink.cpp
@@ -30,6 +30,7 @@ IN THE SOFTWARE.
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/MathExtras.h>
 #include <llvm/Support/raw_ostream.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/CISACodeGen/ShaderCodeGen.hpp"
 #include "Compiler/IGCPassSupport.h"
@@ -79,7 +80,7 @@ IGC_INITIALIZE_PASS_BEGIN(LdShrink, PASS_FLAG, PASS_DESC, PASS_CFG_ONLY, PASS_AN
 IGC_INITIALIZE_PASS_END(LdShrink, PASS_FLAG, PASS_DESC, PASS_CFG_ONLY, PASS_ANALYSIS)
 
 unsigned LdShrink::getExtractIndexMask(LoadInst* LI) const {
-    VectorType* VTy = dyn_cast<VectorType>(LI->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(LI->getType());
     // Skip non-vector loads.
     if (!VTy)
         return 0;
@@ -91,9 +92,12 @@ unsigned LdShrink::getExtractIndexMask(LoadInst* LI) const {
     Type* Ty = VTy->getScalarType();
     // Skip non-BYTE addressable data types. So far, check integer types
     // only.
-    if (IntegerType * ITy = dyn_cast<IntegerType>(Ty))
-        if (!ITy->isPowerOf2ByteWidth())
+    if (IntegerType * ITy = dyn_cast<IntegerType>(Ty)) {
+        // Unroll isPowerOf2ByteWidth, it was removed in LLVM 12.
+        unsigned BitWidth = ITy->getBitWidth();
+        if (!((BitWidth > 7) && isPowerOf2_32(BitWidth)))
             return 0;
+    }
 
     unsigned Mask = 0; // Maxmimally 32 elements.
 
diff --git a/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp b/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp
index c12b20d5..5245117d 100644
--- a/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp
+++ b/IGC/Compiler/CISACodeGen/LowerGEPForPrivMem.cpp
@@ -634,7 +634,7 @@ void TransposeHelper::handleGEPInst(
             }
             else
             {
-                arr_sz = (unsigned)cast<VectorType>(T)->getNumElements();
+                arr_sz = (unsigned)cast<IGCLLVM::FixedVectorType>(T)->getNumElements();
             }
             T = cast<VectorType>(T)->getElementType();
         }
@@ -656,7 +656,7 @@ void TransposeHelper::handleGEPInst(
         }
         else if (T->isVectorTy())
         {
-            arr_sz = (unsigned)cast<VectorType>(T)->getNumElements();
+            arr_sz = (unsigned)cast<IGCLLVM::FixedVectorType>(T)->getNumElements();
             T = cast<VectorType>(T)->getElementType();
         }
         else
@@ -716,7 +716,7 @@ void TransposeHelperPromote::handleLoadInst(
     IRBuilder<> IRB(pLoad);
     IGC_ASSERT(nullptr != pLoad->getType());
     unsigned N = pLoad->getType()->isVectorTy()
-        ? (unsigned)cast<VectorType>(pLoad->getType())->getNumElements()
+        ? (unsigned)cast<IGCLLVM::FixedVectorType>(pLoad->getType())->getNumElements()
         : 1;
     Value* Val = loadEltsFromVecAlloca(N, pVecAlloca, pScalarizedIdx, IRB, pLoad->getType()->getScalarType());
     pLoad->replaceAllUsesWith(Val);
@@ -748,7 +748,7 @@ void TransposeHelperPromote::handleStoreInst(
         // %v1 = extractelement <2 x float> %v, i32 1
         // %w1 = insertelement <32 x float> %w0, float %v1, i32 %idx+1
         // store <32 x float> %w1, <32 x float>* %ptr1
-        for (unsigned i = 0, e = (unsigned)cast<VectorType>(pStoreVal->getType())->getNumElements(); i < e; ++i)
+        for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(pStoreVal->getType())->getNumElements(); i < e; ++i)
         {
             Value* VectorIdx = ConstantInt::get(pScalarizedIdx->getType(), i);
             auto Val = IRB.CreateExtractElement(pStoreVal, VectorIdx);
diff --git a/IGC/Compiler/CISACodeGen/MemOpt.cpp b/IGC/Compiler/CISACodeGen/MemOpt.cpp
index e4279cca..aa788b11 100644
--- a/IGC/Compiler/CISACodeGen/MemOpt.cpp
+++ b/IGC/Compiler/CISACodeGen/MemOpt.cpp
@@ -125,7 +125,7 @@ namespace {
             MemRefListTy& MemRefs, TrivialMemRefListTy& ToOpt);
 
         unsigned getNumElements(Type* Ty) const {
-            return Ty->isVectorTy() ? (unsigned)cast<VectorType>(Ty)->getNumElements() : 1;
+            return Ty->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements() : 1;
         }
 
         MemoryLocation getLocation(Instruction* I) const {
@@ -797,7 +797,7 @@ bool MemOpt::mergeLoad(LoadInst* LeadingLoad,
         Pos = unsigned((std::get<1>(I) - FirstOffset) / LdScalarSize);
 
         if (Ty->isVectorTy()) {
-            if (Pos + cast<VectorType>(Ty)->getNumElements() > NumElts) {
+            if (Pos + cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements() > NumElts) {
                 // This implies we're trying to extract an element from our new load
                 // with an index > the size of the new load.  If this happens,
                 // we'll generate correct code if it does since we don't remove the
@@ -805,7 +805,7 @@ bool MemOpt::mergeLoad(LoadInst* LeadingLoad,
                 continue;
             }
             Value* Val = UndefValue::get(Ty);
-            for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i) {
+            for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i) {
                 Value* Ex = Builder.CreateExtractElement(NewLoad, Builder.getInt32(Pos + i));
                 Ex = createBitOrPointerCast(Ex, ScalarTy, Builder);
                 Val = Builder.CreateInsertElement(Val, Ex, Builder.getInt32(i));
@@ -1083,7 +1083,7 @@ bool MemOpt::mergeStore(StoreInst* LeadingStore,
         IGC_ASSERT(hasSameSize(ScalarTy, LeadingStoreScalarType));
 
         if (Ty->isVectorTy()) {
-            for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i) {
+            for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i) {
                 Value* Ex = Builder.CreateExtractElement(Val, Builder.getInt32(i));
                 Ex = createBitOrPointerCast(Ex, LeadingStoreScalarType, Builder);
                 NewStoreVal = Builder.CreateInsertElement(NewStoreVal, Ex,
diff --git a/IGC/Compiler/CISACodeGen/MemOpt2.cpp b/IGC/Compiler/CISACodeGen/MemOpt2.cpp
index 4b2628d2..20115c73 100644
--- a/IGC/Compiler/CISACodeGen/MemOpt2.cpp
+++ b/IGC/Compiler/CISACodeGen/MemOpt2.cpp
@@ -32,6 +32,7 @@ IN THE SOFTWARE.
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/raw_ostream.h>
 #include <llvm/Transforms/Utils/Local.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 
@@ -124,7 +125,7 @@ namespace {
             if (!Ty->isSingleValueType())
                 return UINT_MAX;
             // Simply return 1 so far for scalar types.
-            VectorType* VecTy = dyn_cast<VectorType>(Ty);
+            IGCLLVM::FixedVectorType* VecTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             if (!VecTy)
                 return 1;
             // Check how that vector is used.
@@ -153,7 +154,7 @@ namespace {
                 return UINT_MAX;
             unsigned EltByte = (Ty->getScalarSizeInBits() + 7) / 8;
             // Simply return 1 so far for scalar types.
-            VectorType* VecTy = dyn_cast<VectorType>(Ty);
+            IGCLLVM::FixedVectorType* VecTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             if (!VecTy)
                 return EltByte;
             // Check how that vector is used.
diff --git a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
index 5baff64f..032d127a 100644
--- a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
@@ -410,7 +410,7 @@ namespace IGC
         unsigned int numElements = 1;
         if (baseType->isVectorTy())
         {
-            numElements = (unsigned)cast<VectorType>(baseType)->getNumElements();
+            numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(baseType)->getNumElements();
             baseType = cast<VectorType>(baseType)->getElementType();
         }
 
diff --git a/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp b/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp
index 356f1141..52396304 100644
--- a/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp
+++ b/IGC/Compiler/CISACodeGen/PatternMatchPass.cpp
@@ -2916,8 +2916,8 @@ namespace IGC
                 llvm::Type* srcTy = bTInst->getOperand(0)->getType();
                 llvm::Type* dstTy = bTInst->getType();
 
-                srcNElts = (srcTy->isVectorTy()) ? (uint32_t)cast<VectorType>(srcTy)->getNumElements() : 1;
-                dstNElts = (dstTy->isVectorTy()) ? (uint32_t)cast<VectorType>(dstTy)->getNumElements() : 1;
+                srcNElts = (srcTy->isVectorTy()) ? (uint32_t)cast<IGCLLVM::FixedVectorType>(srcTy)->getNumElements() : 1;
+                dstNElts = (dstTy->isVectorTy()) ? (uint32_t)cast<IGCLLVM::FixedVectorType>(dstTy)->getNumElements() : 1;
 
                 if (srcNElts < dstNElts && srcTy->getScalarSizeInBits() < 64)
                 {
diff --git a/IGC/Compiler/CISACodeGen/PushAnalysis.cpp b/IGC/Compiler/CISACodeGen/PushAnalysis.cpp
index ba8c2770..8da82db0 100644
--- a/IGC/Compiler/CISACodeGen/PushAnalysis.cpp
+++ b/IGC/Compiler/CISACodeGen/PushAnalysis.cpp
@@ -899,7 +899,7 @@ namespace IGC
 
         if (pTypeToPush->isVectorTy())
         {
-            num_elms = (unsigned)cast<VectorType>(pTypeToPush)->getNumElements();
+            num_elms = (unsigned)cast<IGCLLVM::FixedVectorType>(pTypeToPush)->getNumElements();
             pTypeToPush = cast<VectorType>(pTypeToPush)->getElementType();
             llvm::Type* pVecTy = IGCLLVM::FixedVectorType::get(pTypeToPush, num_elms);
             pReplacedInst = llvm::UndefValue::get(pVecTy);
@@ -1102,7 +1102,7 @@ namespace IGC
         }
 
         unsigned num_elms =
-            inst->getType()->isVectorTy() ? (unsigned)cast<VectorType>(inst->getType())->getNumElements() : 1;
+            inst->getType()->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements() : 1;
         llvm::Type* pTypeToPush = inst->getType();
         llvm::Value* replaceVector = nullptr;
         unsigned int numberChannelReplaced = 0;
diff --git a/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp b/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp
index 95b937e7..1c6544a4 100644
--- a/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp
+++ b/IGC/Compiler/CISACodeGen/RegisterEstimator.cpp
@@ -41,6 +41,7 @@ IN THE SOFTWARE.
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Support/MathExtras.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
 
@@ -146,7 +147,7 @@ RegUse RegisterEstimator::estimateNumOfRegs(Value* V) const
     Type* Ty = V->getType();
     if (!Ty->isVoidTy())
     {
-        VectorType* VTy = dyn_cast<VectorType>(Ty);
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         Type* eltTy = VTy ? VTy->getElementType() : Ty;
         uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
         uint32_t eltBits = (uint32_t)m_DL->getTypeSizeInBits(eltTy);
diff --git a/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp b/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp
index beac138d..ceeafa48 100644
--- a/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp
+++ b/IGC/Compiler/CISACodeGen/RegisterPressureEstimate.hpp
@@ -42,6 +42,7 @@ See LRCENSE.TXT for details.
 #include "llvm/Pass.h"
 #include <llvm/IR/InstVisitor.h>
 #include "llvm/Analysis/LoopInfo.h"
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/IGCPassSupport.h"
 #include "Compiler/CISACodeGen/WIAnalysis.hpp"
@@ -240,7 +241,7 @@ namespace IGC
             auto Ty = V->getType();
             if (Ty->isVoidTy())
                 return 0;
-            auto VTy = llvm::dyn_cast<llvm::VectorType>(Ty);
+            auto VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(Ty);
             auto eltTy = VTy ? VTy->getElementType() : Ty;
             uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
             uint32_t eltBits = (uint32_t)m_DL->getTypeSizeInBits(eltTy);
diff --git a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
index 962083f4..26a7b8be 100644
--- a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
+++ b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
@@ -39,6 +39,7 @@ IN THE SOFTWARE.
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Support/Debug.h>
 #include <llvm/Support/MathExtras.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include <vector>
 #include "Probe/Assertion.h"
@@ -629,7 +630,7 @@ bool SLMConstProp::isEqual(Constant* C0, Constant* C1)
 
 bool SLMConstProp::isFloatType(Type* Ty)
 {
-    if (VectorType * vTy = dyn_cast<VectorType>(Ty))
+    if (IGCLLVM::FixedVectorType * vTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty))
     {
         if (vTy->getNumElements() > 1)
         {
diff --git a/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp b/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp
index ce816416..32ab79c1 100644
--- a/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/ScalarizerCodeGen.cpp
@@ -66,7 +66,7 @@ void ScalarizerCodeGen::visitBinaryOperator(llvm::BinaryOperator& I)
         {
             bool isNewTypeVector = false;
 
-            VectorType* instType = cast<VectorType>(I.getType());
+            IGCLLVM::FixedVectorType* instType = cast<IGCLLVM::FixedVectorType>(I.getType());
             unsigned numElements = int_cast<unsigned>(instType->getNumElements());
             unsigned scalarSize = instType->getScalarSizeInBits();
             unsigned newScalarBits = numElements * scalarSize;
@@ -111,7 +111,7 @@ void ScalarizerCodeGen::visitBinaryOperator(llvm::BinaryOperator& I)
                 }
                 else
                 {
-                    VectorType* newVecType = cast<VectorType>(newType);
+                    IGCLLVM::FixedVectorType* newVecType = cast<IGCLLVM::FixedVectorType>(newType);
                     unsigned newVecTypeNumEle = int_cast<unsigned>(newVecType->getNumElements());
                     Value* ieLogicOp = UndefValue::get(newType);
                     for (unsigned i = 0; i < newVecTypeNumEle; i++)
diff --git a/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp b/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp
index d7baf806..e6fbdf23 100644
--- a/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/ShaderCodeGen.cpp
@@ -589,12 +589,14 @@ static void AddLegalizationPasses(CodeGenContext& ctx, IGCPassManager& mpm, PSSi
     {
         mpm.add(createPruneUnusedArgumentsPass());
 
+#if LLVM_VERSION_MAJOR < 12
         if (IGC_GET_FLAG_VALUE(FunctionControl) == FLAG_FCALL_DEFAULT)
         {
             // Don't run IPConstantProp when debugging function calls, to avoid folding function arg/ret constants
             mpm.add(createIPConstantPropagationPass());
         }
         mpm.add(createConstantPropagationPass());
+#endif
         mpm.add(createDeadCodeEliminationPass());
         mpm.add(createCFGSimplificationPass());
     }
@@ -1475,8 +1477,10 @@ void OptimizeIR(CodeGenContext* const pContext)
             // possible which potentially allows late stage code sinking of
             // those calls by the instruction combiner.
             mpm.add(createPostOrderFunctionAttrsLegacyPass());
+#if LLVM_VERSION_MAJOR < 12
             mpm.add(createConstantPropagationPass());
             mpm.add(createIPConstantPropagationPass());
+#endif
         }
 
         // enable this only when Pooled EU is not supported
diff --git a/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp b/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp
index 87ba2751..c1f4a419 100644
--- a/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp
+++ b/IGC/Compiler/CISACodeGen/Simd32Profitability.cpp
@@ -30,6 +30,7 @@ IN THE SOFTWARE.
 #include <llvmWrapper/IR/DerivedTypes.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/IR/Operator.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 #include "GenISAIntrinsics/GenIntrinsicInst.h"
@@ -577,7 +578,7 @@ static bool isPayloadHeader(Value* V) {
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 8 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -588,7 +589,7 @@ static bool isR0(Value* V) {
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 8 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -599,7 +600,7 @@ static bool isEnqueuedLocalSize(Value* V) {
     Argument* Arg = dyn_cast<Argument>(V);
     if (!Arg || !Arg->hasName())
         return false;
-    VectorType* VTy = dyn_cast<VectorType>(Arg->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Arg->getType());
     if (!VTy || VTy->getNumElements() != 3 ||
         !VTy->getElementType()->isIntegerTy(32))
         return false;
@@ -994,7 +995,11 @@ static bool hasLongStridedLdStInLoop(Function* F, LoopInfo* LI, WIAnalysis* WI)
     // Collect innermost simple loop.
     for (auto I = LI->begin(), E = LI->end(); I != E; ++I) {
         auto L = *I;
+#if LLVM_VERSION_MAJOR >= 12
+        if (!L->isInnermost())
+#else
         if (!L->empty())
+#endif
             continue;
         if (L->getNumBlocks() != 2)
             continue;
diff --git a/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp b/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp
index 73f472b5..0069c4b1 100644
--- a/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp
+++ b/IGC/Compiler/CISACodeGen/SimplifyConstant.cpp
@@ -352,7 +352,7 @@ static unsigned getLegalVectorSize(unsigned N) {
 // Check vector size. We may demote the data type if all values can fit into
 // smaller data type.
 //
-static bool checkSize(GlobalVariable* GV, VectorType*& DataType,
+static bool checkSize(GlobalVariable* GV, IGCLLVM::FixedVectorType*& DataType,
     bool& IsSigned) {
     Constant* Init = GV->getInitializer();
     IGC_ASSERT(isa<ArrayType>(Init->getType()));
@@ -360,7 +360,7 @@ static bool checkSize(GlobalVariable* GV, VectorType*& DataType,
     unsigned N = (unsigned)ArrayTy->getArrayNumElements();
     Type* BaseTy = ArrayTy->getArrayElementType();
     unsigned VectorSize = 1;
-    if (auto VT = dyn_cast<VectorType>(BaseTy)) {
+    if (auto VT = dyn_cast<IGCLLVM::FixedVectorType>(BaseTy)) {
         BaseTy = VT->getElementType();
         VectorSize = int_cast<unsigned>(VT->getNumElements());
         N *= VectorSize;
@@ -483,7 +483,7 @@ static Constant* getConstantVal(Type* VEltTy, Constant* V, bool IsSigned) {
     return ConstantInt::get(VEltTy, IVal, IsSigned);
 }
 
-static void promote(GlobalVariable* GV, VectorType* AllocaType, bool IsSigned,
+static void promote(GlobalVariable* GV, IGCLLVM::FixedVectorType* AllocaType, bool IsSigned,
     Function* F) {
     // Build the constant vector from constant array.
     unsigned VS = int_cast<unsigned>(AllocaType->getNumElements());
@@ -507,7 +507,7 @@ static void promote(GlobalVariable* GV, VectorType* AllocaType, bool IsSigned,
             Constant* const Elt = CA->getAggregateElement(i);
             IGC_ASSERT_MESSAGE(nullptr != Elt, "Null AggregateElement");
             if (auto EltTy = dyn_cast<VectorType>(Elt->getType())) {
-                unsigned VectorSize = (unsigned)cast<VectorType>(EltTy)->getNumElements();
+                unsigned VectorSize = (unsigned)cast<IGCLLVM::FixedVectorType>(EltTy)->getNumElements();
                 for (unsigned j = 0; j < VectorSize; ++j) {
                     Constant* V = Elt->getAggregateElement(j);
                     Vals[i * VectorSize + j] = getConstantVal(VEltTy, V, IsSigned);
@@ -549,7 +549,7 @@ static void promote(GlobalVariable* GV, VectorType* AllocaType, bool IsSigned,
             unsigned N = 1;
             Value* Offset = Index;
             if (Ty->isVectorTy()) {
-                N = (unsigned)cast<VectorType>(Ty)->getNumElements();
+                N = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
                 Offset = Builder.CreateMul(Offset, ConstantInt::get(Offset->getType(), N));
             }
             Value* Val = extractNElts(N, VectorData, Offset, Builder);
@@ -684,7 +684,7 @@ bool PromoteConstant::runOnFunction(Function& F) {
 
         // If possible demote the data into smaller type. Uses of value will be
         // promoted back with ZExt or SExt.
-        VectorType* AllocaType = nullptr;
+        IGCLLVM::FixedVectorType* AllocaType = nullptr;
         bool IsSigned = false;
         if (!checkSize(GV, AllocaType, IsSigned))
             continue;
diff --git a/IGC/Compiler/CISACodeGen/TypeDemote.cpp b/IGC/Compiler/CISACodeGen/TypeDemote.cpp
index eb7a7b64..b04a0f6e 100644
--- a/IGC/Compiler/CISACodeGen/TypeDemote.cpp
+++ b/IGC/Compiler/CISACodeGen/TypeDemote.cpp
@@ -32,6 +32,7 @@ IN THE SOFTWARE.
 #include <llvm/ADT/PostOrderIterator.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/Pass.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 #include "Probe/Assertion.h"
@@ -288,7 +289,7 @@ bool TypeDemote::demoteOnBasicBlock(BasicBlock* BB) const {
             CastInst* CI = dyn_cast<CastInst>(Index);
             if (CI && (CI->getOpcode() == Instruction::ZExt ||
                 CI->getOpcode() == Instruction::SExt)) {
-                unsigned VS = (unsigned)cast<VectorType>(EEI->getVectorOperandType())->getNumElements();
+                unsigned VS = (unsigned)cast<IGCLLVM::FixedVectorType>(EEI->getVectorOperandType())->getNumElements();
                 unsigned N = (unsigned int)CI->getSrcTy()->getPrimitiveSizeInBits();
                 unsigned Bound = (N < 32) ? (1U << N) : UINT32_MAX;
                 if (VS <= Bound) {
diff --git a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp
index 1cac7b12..12c4734e 100644
--- a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp
+++ b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.cpp
@@ -28,6 +28,7 @@ IN THE SOFTWARE.
 #include "Compiler/CodeGenPublic.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/Support/Debug.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include <algorithm>
 #include "Probe/Assertion.h"
@@ -40,13 +41,13 @@ namespace
     // If V is scalar, return 1.
     // if V is vector, return the number of elements.
     inline int getNumElts(Value* V) {
-        VectorType* VTy = dyn_cast<VectorType>(V->getType());
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(V->getType());
         return VTy ? (int)VTy->getNumElements() : 1;
     }
 
     inline int getTypeSizeInBits(Type* Ty) {
         int scalarBits = Ty->getScalarSizeInBits();
-        VectorType* VTy = dyn_cast<VectorType>(Ty);
+        IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         return scalarBits * (VTy ? (int)VTy->getNumElements() : 1);
     }
 }
diff --git a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp
index 56dac17e..42081dca 100644
--- a/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp
+++ b/IGC/Compiler/CISACodeGen/VariableReuseAnalysis.hpp
@@ -37,6 +37,7 @@ IN THE SOFTWARE.
 #include <llvm/IR/InstIterator.h>
 #include <llvm/IR/InstVisitor.h>
 #include "llvm/Pass.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/Support/raw_ostream.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/CISACodeGen/RegisterEstimator.hpp"
@@ -79,7 +80,7 @@ namespace IGC {
         SSubVecDesc(llvm::Value* V)
             : Aliaser(V), BaseVector(V), StartElementOffset(0)
         {
-            llvm::VectorType* VTy = llvm::dyn_cast<llvm::VectorType>(V->getType());
+            IGCLLVM::FixedVectorType* VTy = llvm::dyn_cast<IGCLLVM::FixedVectorType>(V->getType());
             NumElts = VTy ? (short)VTy->getNumElements() : 1;
         }
 
diff --git a/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp b/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp
index 4c2b0644..4cd6a2db 100644
--- a/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp
+++ b/IGC/Compiler/CISACodeGen/VectorPreProcess.cpp
@@ -500,7 +500,7 @@ void VectorPreProcess::replaceAllVectorUsesWithScalars(Instruction* VI, ValVecto
             I = VI->getParent()->getFirstNonPHI();
         }
         IRBuilder<> Builder(I);
-        VectorType* VTy = cast<VectorType>(VI->getType());
+        IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(VI->getType());
         Value* newVec = UndefValue::get(VTy);
         for (uint32_t i = 0, e = int_cast<uint32_t>(VTy->getNumElements()); i < e; ++i)
         {
@@ -619,7 +619,7 @@ bool VectorPreProcess::splitStore(
 {
     Instruction* SI = ASI.getInst();
     Value* StoredVal = ASI.getValueOperand();
-    VectorType* VTy = cast<VectorType>(StoredVal->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(StoredVal->getType());
     Type* ETy = VTy->getElementType();
     uint32_t nelts = int_cast<uint32_t>(VTy->getNumElements());
 
@@ -705,7 +705,7 @@ bool VectorPreProcess::splitStore(
         {
             Type* Ty1 = splitInfo[i].first;
             uint32_t len1 = splitInfo[i].second;
-            VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+            IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
             for (uint32_t j = 0; j < len1; ++j)
             {
                 Value* subVec;
@@ -742,7 +742,7 @@ bool VectorPreProcess::splitStore(
     {
         Type* Ty1 = splitInfo[i].first;
         uint32_t len1 = splitInfo[i].second;
-        VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+        IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
         for (uint32_t j = 0; j < len1; ++j)
         {
             uint32_t vAlign = (uint32_t)MinAlign(Align, (uint32_t)eOffset * EBytes);
@@ -786,7 +786,7 @@ bool VectorPreProcess::splitLoad(
 {
     Instruction* LI = ALI.getInst();
     bool isLdRaw = isa<LdRawIntrinsic>(LI);
-    VectorType* VTy = cast<VectorType>(LI->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(LI->getType());
     Type* ETy = VTy->getElementType();
     uint32_t nelts = int_cast<uint32_t>(VTy->getNumElements());
 
@@ -848,7 +848,7 @@ bool VectorPreProcess::splitLoad(
     {
         Type* Ty1 = splitInfo[i].first;
         uint32_t len1 = splitInfo[i].second;
-        VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+        IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
         for (uint32_t j = 0; j < len1; ++j)
         {
             uint32_t vAlign = (uint32_t)MinAlign(Align, eOffset * EBytes);
@@ -916,7 +916,7 @@ bool VectorPreProcess::splitLoadStore(
     Optional<AbstractStoreInst> ASI = AbstractStoreInst::get(Inst);
     IGC_ASSERT_MESSAGE((ALI || ASI), "Inst should be either load or store");
     Type* Ty = ALI ? ALI->getInst()->getType() : ASI->getValueOperand()->getType();
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     if (!VTy)
     {
         return false;
@@ -1147,7 +1147,7 @@ void VectorPreProcess::getOrGenScalarValues(
 {
     availBeforeInst = nullptr;
 
-    VectorType* VTy = cast<VectorType>(VecVal->getType());
+    IGCLLVM::FixedVectorType* VTy = cast<IGCLLVM::FixedVectorType>(VecVal->getType());
     if (!VTy)
     {
         scalars[0] = VecVal;
@@ -1298,7 +1298,7 @@ Instruction* VectorPreProcess::simplifyLoadStore(Instruction* Inst)
         //
         // TODO: further optimize this load into a message with channel masks
         // for cases in which use indices are sparse like {0, 2}.
-        unsigned N = (unsigned)cast<VectorType>(Inst->getType())->getNumElements();
+        unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(Inst->getType())->getNumElements();
         if (N == MaxIndex + 1)
             return Inst;
 
@@ -1355,7 +1355,7 @@ Instruction* VectorPreProcess::simplifyLoadStore(Instruction* Inst)
     if (NBits < 32)
         return Inst;
 
-    unsigned N = (unsigned)cast<VectorType>(Val->getType())->getNumElements();
+    unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(Val->getType())->getNumElements();
     if (auto CV = dyn_cast<ConstantVector>(Val))
     {
         unsigned MaxIndex = 0;
@@ -1524,7 +1524,7 @@ bool VectorPreProcess::runOnFunction(Function& F)
                 for (uint32_t j = 0; j < svals.size(); ++j)
                 {
                     Type* Ty1 = svals[j]->getType();
-                    VectorType* VTy1 = dyn_cast<VectorType>(Ty1);
+                    IGCLLVM::FixedVectorType* VTy1 = dyn_cast<IGCLLVM::FixedVectorType>(Ty1);
                     if (VTy1) {
                         for (uint32_t k = 0; k < VTy1->getNumElements(); ++k)
                         {
@@ -1573,7 +1573,7 @@ bool VectorPreProcess::runOnFunction(Function& F)
                     // If this is a 3-element vector load, remove it
                     // from m_Vector3List as well.
                     if (isAbstractLoadInst(tInst) && tInst->getType()->isVectorTy() &&
-                        cast<VectorType>(tInst->getType())->getNumElements() == 3)
+                        cast<IGCLLVM::FixedVectorType>(tInst->getType())->getNumElements() == 3)
                     {
                         InstWorkVector::iterator
                             tI = m_Vector3List.begin(),
diff --git a/IGC/Compiler/CISACodeGen/VectorProcess.cpp b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
index 9f39cdc0..cfe45321 100644
--- a/IGC/Compiler/CISACodeGen/VectorProcess.cpp
+++ b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
@@ -240,7 +240,7 @@ bool VectorProcess::reLayoutLoadStore(Instruction* Inst)
     IGC_ASSERT(nullptr != Ptr);
     IGC_ASSERT(nullptr != Ty);
 
-    VectorType* const VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* const VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
 
     // Treat a scalar as 1-element vector
     uint32_t nelts = VTy ? int_cast<uint32_t>(VTy->getNumElements()) : 1;
@@ -654,7 +654,7 @@ void VectorMessage::getInfo(Type* Ty, uint32_t Align, bool useA32,
     VectorType* VTy = dyn_cast<VectorType>(Ty);
     Type* eTy = VTy ? cast<VectorType>(VTy)->getElementType() : Ty;
     unsigned eltSize = m_emitter->GetScalarTypeSizeInRegister(eTy);
-    unsigned nElts = VTy ? (unsigned)cast<VectorType>(VTy)->getNumElements() : 1;
+    unsigned nElts = VTy ? (unsigned)cast<IGCLLVM::FixedVectorType>(VTy)->getNumElements() : 1;
     // total bytes
     const unsigned TBytes = nElts * eltSize;
 
diff --git a/IGC/Compiler/CISACodeGen/helper.cpp b/IGC/Compiler/CISACodeGen/helper.cpp
index 784affaa..e5507283 100644
--- a/IGC/Compiler/CISACodeGen/helper.cpp
+++ b/IGC/Compiler/CISACodeGen/helper.cpp
@@ -1634,7 +1634,7 @@ namespace IGC
             {
                 instList[i] = builder.CreateExtractElement(val, static_cast<uint64_t>(0));
                 size_t iOld = i;
-                for (unsigned j = 1; j < cast<VectorType>(val->getType())->getNumElements(); j++)
+                for (unsigned j = 1; j < cast<IGCLLVM::FixedVectorType>(val->getType())->getNumElements(); j++)
                 {
                     instList.insert(instList.begin()+ iOld +j, builder.CreateExtractElement(val, j));
                     i++;
@@ -1667,7 +1667,7 @@ namespace IGC
             }
             break;
         case IGCLLVM::VectorTyID:
-            num = (unsigned)cast<VectorType>(type)->getNumElements();
+            num = (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements();
             for (unsigned i = 0; i < num; i++)
             {
                 ScalarizeAggregateMembers(builder, builder.CreateExtractElement(val, i), instList);
@@ -1707,7 +1707,7 @@ namespace IGC
             }
             break;
         case IGCLLVM::VectorTyID:
-            num = (unsigned)cast<VectorType>(type)->getNumElements();
+            num = (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements();
             for (unsigned i = 0; i < num; i++)
             {
                 indices.push_back(builder.getInt32(i));
@@ -1972,8 +1972,8 @@ namespace IGC
                 return false;
             }
 
-            VectorType* dVTy = dyn_cast<VectorType>(dTy);
-            VectorType* sVTy = dyn_cast<VectorType>(sTy);
+            IGCLLVM::FixedVectorType* dVTy = dyn_cast<IGCLLVM::FixedVectorType>(dTy);
+            IGCLLVM::FixedVectorType* sVTy = dyn_cast<IGCLLVM::FixedVectorType>(sTy);
             int d_nelts = dVTy ? (int)dVTy->getNumElements() : 1;
             int s_nelts = sVTy ? (int)sVTy->getNumElements() : 1;
             if (d_nelts != s_nelts) {
diff --git a/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp b/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp
index cd7fc66e..adf992cb 100644
--- a/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp
+++ b/IGC/Compiler/ConvertMSAAPayloadTo16Bit.cpp
@@ -153,15 +153,24 @@ void ConvertMSAAPayloadTo16Bit::visitCallInst(CallInst& I)
             // In OGL there are uses of ldmcs other then ldms, using vec4float type.
             // Fix them to use newly created 16bit ldmcs.
             if (ldmcs->getType()->isVectorTy() &&
+#if LLVM_VERSION_MAJOR >= 12
+                ldmcs->getType()->getScalarType()->isFloatTy())
+#else
                 ldmcs->getType()->getVectorElementType()->isFloatTy())
+#endif
             {
                 m_builder->SetInsertPoint(ldmcs);
 
+#if LLVM_VERSION_MAJOR >= 12
+                uint ldmcsNumOfElements = cast<IGCLLVM::FixedVectorType>(ldmcs->getType())->getNumElements();
+                uint new_mcs_callNumOfElements = cast<IGCLLVM::FixedVectorType>(new_mcs_call->getType())->getNumElements();
+#else
                 uint ldmcsNumOfElements = ldmcs->getType()->getVectorNumElements();
                 uint new_mcs_callNumOfElements = new_mcs_call->getType()->getVectorNumElements();
+#endif
 
                 // vec of 16bit ints to vec of 32bit ints
-                Type* new_mcs_callVecType = VectorType::get(m_builder->getInt32Ty(), new_mcs_callNumOfElements);
+                Type* new_mcs_callVecType = IGCLLVM::FixedVectorType::get(m_builder->getInt32Ty(), new_mcs_callNumOfElements);
                 Value* ldmcsExtendedToInt32 = m_builder->CreateSExt(new_mcs_call, new_mcs_callVecType);
 
                 // if new ldmcs has fewer elements than ldmcs, extend vector
@@ -175,7 +184,7 @@ void ConvertMSAAPayloadTo16Bit::visitCallInst(CallInst& I)
                     }
                     auto* pMask = ConstantDataVector::get(I.getContext(), maskVals);
 
-                    newLdmcsSizedVector = m_builder->CreateShuffleVector(ldmcsExtendedToInt32, UndefValue::get(VectorType::get(m_builder->getInt32Ty(), ldmcsNumOfElements)), pMask);
+                    newLdmcsSizedVector = m_builder->CreateShuffleVector(ldmcsExtendedToInt32, UndefValue::get(IGCLLVM::FixedVectorType::get(m_builder->getInt32Ty(), ldmcsNumOfElements)), pMask);
                 }
                 else
                 {
@@ -183,7 +192,7 @@ void ConvertMSAAPayloadTo16Bit::visitCallInst(CallInst& I)
                 }
                 IGC_ASSERT(newLdmcsSizedVector);
 
-                Type* ldmcsFloatVecType = VectorType::get(m_builder->getFloatTy(), ldmcsNumOfElements);
+                Type* ldmcsFloatVecType = IGCLLVM::FixedVectorType::get(m_builder->getFloatTy(), ldmcsNumOfElements);
                 Value* ldmcsBitcastedToFloat = m_builder->CreateBitCast(ldmcsExtendedToInt32, ldmcsFloatVecType);
                 ldmcs->replaceAllUsesWith(ldmcsBitcastedToFloat);
             }
diff --git a/IGC/Compiler/CustomSafeOptPass.cpp b/IGC/Compiler/CustomSafeOptPass.cpp
index 707bbfbe..72859a91 100644
--- a/IGC/Compiler/CustomSafeOptPass.cpp
+++ b/IGC/Compiler/CustomSafeOptPass.cpp
@@ -1372,7 +1372,7 @@ void IGC::CustomSafeOptPass::visitSampleBptr(llvm::SampleIntrinsic* sampleInst)
 bool CustomSafeOptPass::isIdentityMatrix(ExtractElementInst& I)
 {
     bool found = false;
-    auto extractType = cast<VectorType>(I.getVectorOperandType());
+    auto extractType = cast<IGCLLVM::FixedVectorType>(I.getVectorOperandType());
     auto extractTypeVecSize = (uint32_t)extractType->getNumElements();
     if (extractTypeVecSize == 20 ||
         extractTypeVecSize == 16)
@@ -1601,7 +1601,7 @@ void CustomSafeOptPass::visitExtractElementInst(ExtractElementInst& I)
                     int elOffset = (int)(bitShift / eltSize);
                     elOffset = rightShift ? elOffset : -elOffset;
                     unsigned int newIndex = (unsigned int)((int)cstIndex->getZExtValue() + elOffset);
-                    if (newIndex < cast<VectorType>(vecType)->getNumElements())
+                    if (newIndex < cast<IGCLLVM::FixedVectorType>(vecType)->getNumElements())
                     {
                         IRBuilder<> builder(&I);
                         Value* newBitCast = builder.CreateBitCast(binOp->getOperand(0), vecType);
@@ -2001,7 +2001,7 @@ void GenSpecificPattern::createBitcastExtractInsertPattern(BinaryOperator& I, Va
         else if (auto IEIInst = dyn_cast<InsertElementInst>(Op))
         {
             auto opType = IEIInst->getType();
-            if (opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<VectorType>(opType)->getNumElements() == 2)
+            if (opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<IGCLLVM::FixedVectorType>(opType)->getNumElements() == 2)
             {
                 elem = IEIInst->getOperand(1);
             }
@@ -2064,7 +2064,7 @@ void GenSpecificPattern::visitBinaryOperator(BinaryOperator& I)
         else if (match(&I, pattern2) && AndOp2->getType()->isIntegerTy(64))
         {
             ConstantVector* cVec = dyn_cast<ConstantVector>(VecOp);
-            VectorType* vector_type = dyn_cast<VectorType>(VecOp->getType());
+            IGCLLVM::FixedVectorType* vector_type = dyn_cast<IGCLLVM::FixedVectorType>(VecOp->getType());
             if (cVec && vector_type &&
                 isa<ConstantInt>(cVec->getOperand(0)) &&
                 cast<ConstantInt>(cVec->getOperand(0))->isZero() &&
@@ -2210,7 +2210,7 @@ void GenSpecificPattern::visitBinaryOperator(BinaryOperator& I)
             BitCastInst* opBC = cast<BitCastInst>(op);
 
             auto opType = opBC->getType();
-            if (!(opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<VectorType>(opType)->getNumElements() == 2))
+            if (!(opType->isVectorTy() && cast<VectorType>(opType)->getElementType()->isIntegerTy(32) && cast<IGCLLVM::FixedVectorType>(opType)->getNumElements() == 2))
                 return nullptr;
 
             if (opBC->getSrcTy()->isDoubleTy())
@@ -2630,8 +2630,8 @@ void GenSpecificPattern::visitBitCastInst(BitCastInst& I)
                 if (zExtInst->getOperand(0)->getType()->isIntegerTy(32) &&
                     isa<InsertElementInst>(bitCastInst->getOperand(0)) &&
                     bitCastInst->getOperand(0)->getType()->isVectorTy() &&
-                    cast<VectorType>(bitCastInst->getOperand(0)->getType())->getElementType()->isIntegerTy(32) &&
-                    cast<VectorType>(bitCastInst->getOperand(0)->getType())->getNumElements() == 2)
+                    cast<IGCLLVM::FixedVectorType>(bitCastInst->getOperand(0)->getType())->getElementType()->isIntegerTy(32) &&
+                    cast<IGCLLVM::FixedVectorType>(bitCastInst->getOperand(0)->getType())->getNumElements() == 2)
                 {
                     InsertElementInst* insertElementInst = cast<InsertElementInst>(bitCastInst->getOperand(0));
 
@@ -2731,7 +2731,7 @@ void GenSpecificPattern::visitFNeg(llvm::UnaryOperator& I)
     }
     else
     {
-        uint32_t vectorSize = cast<VectorType>(I.getType())->getNumElements();
+        uint32_t vectorSize = cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
         fsub = llvm::UndefValue::get(I.getType());
 
         for (uint32_t i = 0; i < vectorSize; ++i)
@@ -2845,7 +2845,7 @@ Constant* IGCConstProp::replaceShaderConstant(LoadInst* inst)
                 if (inst->getType()->isVectorTy())
                 {
                     Type* srcEltTy = cast<VectorType>(inst->getType())->getElementType();
-                    uint32_t srcNElts = (uint32_t)cast<VectorType>(inst->getType())->getNumElements();
+                    uint32_t srcNElts = (uint32_t)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
                     uint32_t eltSize_in_bytes = (unsigned int)srcEltTy->getPrimitiveSizeInBits() / 8;
                     IRBuilder<> builder(inst);
                     Value* vectorValue = UndefValue::get(inst->getType());
@@ -3122,7 +3122,7 @@ Constant* IGCConstProp::ConstantFoldCmpInst(CmpInst* CI)
     {
         bool AllTrue = true, AllFalse = true;
         auto VecOpnd = cast<Constant>(EEI->getVectorOperand());
-        unsigned N = (unsigned)cast<VectorType>(VecOpnd->getType())->getNumElements();
+        unsigned N = (unsigned)cast<IGCLLVM::FixedVectorType>(VecOpnd->getType())->getNumElements();
         for (unsigned i = 0; i < N; ++i)
         {
             Constant* const Opnd = VecOpnd->getAggregateElement(i);
@@ -3918,8 +3918,8 @@ namespace IGC
                 BitCastInst* BC = dyn_cast<BitCastInst>(&*BI++);
                 if (!BC) continue;
                 // Skip non-element-wise bitcast.
-                VectorType* DstVTy = dyn_cast<VectorType>(BC->getType());
-                VectorType* SrcVTy = dyn_cast<VectorType>(BC->getOperand(0)->getType());
+                IGCLLVM::FixedVectorType* DstVTy = dyn_cast<IGCLLVM::FixedVectorType>(BC->getType());
+                IGCLLVM::FixedVectorType* SrcVTy = dyn_cast<IGCLLVM::FixedVectorType>(BC->getOperand(0)->getType());
                 if (!DstVTy || !SrcVTy || DstVTy->getNumElements() != SrcVTy->getNumElements())
                     continue;
                 // Skip if it's not used only all extractelement.
@@ -4689,7 +4689,7 @@ void SplitIndirectEEtoSel::visitExtractElementInst(llvm::ExtractElementInst& I)
 {
     using namespace llvm::PatternMatch;
 
-    VectorType* vecTy = I.getVectorOperandType();
+    IGCLLVM::FixedVectorType* vecTy = dyn_cast<IGCLLVM::FixedVectorType>(I.getVectorOperandType());
     uint64_t num = vecTy->getNumElements();
     Type* eleType = vecTy->getElementType();
 
diff --git a/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp b/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp
index 885ad65a..923f296e 100644
--- a/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp
+++ b/IGC/Compiler/DebugInfo/ScalarVISAModule.cpp
@@ -32,6 +32,7 @@ IN THE SOFTWARE.
 #include "DebugInfo/DebugInfoUtils.hpp"
 
 #include "common/LLVMWarningsPush.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/Module.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -581,7 +582,7 @@ ScalarVisaModule::GetVariableLocation(const llvm::Instruction* pInst) const
 
         if (pType->isVectorTy())
         {
-            vectorNumElements = (unsigned)cast<VectorType>(pType)->getNumElements();
+            vectorNumElements = (unsigned)cast<IGCLLVM::FixedVectorType>(pType)->getNumElements();
         }
         else if (!pVar->IsUniform())
         {
diff --git a/IGC/Compiler/GenTTI.cpp b/IGC/Compiler/GenTTI.cpp
index 34b21c73..9e4d2f26 100644
--- a/IGC/Compiler/GenTTI.cpp
+++ b/IGC/Compiler/GenTTI.cpp
@@ -216,7 +216,13 @@ namespace llvm {
 
         // Skip non-simple loop.
         if (L->getNumBlocks() != 1) {
-            if (IGC_IS_FLAG_ENABLED(EnableAdvRuntimeUnroll) && L->empty()) {
+            if (IGC_IS_FLAG_ENABLED(EnableAdvRuntimeUnroll) &&
+#if LLVM_VERSION_MAJOR >= 12
+                L->isInnermost()
+#else
+                L->empty()
+#endif
+               ) {
                 auto countNonPHI = [](BasicBlock* BB) {
                     unsigned Total = BB->size();
                     unsigned PHIs = 0;
diff --git a/IGC/Compiler/GenUpdateCB.cpp b/IGC/Compiler/GenUpdateCB.cpp
index 89b414b6..9034066c 100644
--- a/IGC/Compiler/GenUpdateCB.cpp
+++ b/IGC/Compiler/GenUpdateCB.cpp
@@ -24,6 +24,7 @@ IN THE SOFTWARE.
 
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/Bitcode/BitcodeWriter.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include <llvm/Support/ScaledNumber.h>
 #include <llvm/Bitcode/BitcodeReader.h>
 #include "llvm/IR/DebugInfo.h"
@@ -384,7 +385,7 @@ bool GenUpdateCB::runOnFunction(Function& F)
                     isResInfo(dyn_cast<GenIntrinsicInst>(inst,
                         GenISAIntrinsic::GenISA_resinfoptr), texId, lod, isUAV))
                 {
-                    unsigned nelems = (unsigned)cast<VectorType>(inst->getType())->getNumElements();
+                    unsigned nelems = (unsigned)cast<IGCLLVM::FixedVectorType>(inst->getType())->getNumElements();
                     SmallVector< SmallVector<ExtractElementInst*, 1>, 4> extracts(nelems);
                     if (VectorUsedByConstExtractOnly(inst, extracts))
                     {
diff --git a/IGC/Compiler/HandleFRemInstructions.cpp b/IGC/Compiler/HandleFRemInstructions.cpp
index 94995a56..4523f3f0 100644
--- a/IGC/Compiler/HandleFRemInstructions.cpp
+++ b/IGC/Compiler/HandleFRemInstructions.cpp
@@ -28,6 +28,7 @@ IN THE SOFTWARE.
 #include <llvm/IR/Instructions.h>
 #include <llvm/IR/InstIterator.h>
 #include <llvm/Transforms/Utils/BasicBlockUtils.h>
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/IGCPassSupport.h"
 #include "Probe/Assertion.h"
@@ -77,7 +78,7 @@ void HandleFRemInstructions::visitFRem(llvm::BinaryOperator& I)
 
     if (ValType->isVectorTy())
     {
-        auto VecCount = cast<VectorType>(ValType)->getNumElements();
+        auto VecCount = cast<IGCLLVM::FixedVectorType>(ValType)->getNumElements();
         if (VecCount == 2 || VecCount == 3 || VecCount == 4 || VecCount == 8 || VecCount == 16)
         {
             VecStr = "v" + std::to_string(VecCount);
diff --git a/IGC/Compiler/HandleLoadStoreInstructions.cpp b/IGC/Compiler/HandleLoadStoreInstructions.cpp
index d18eec73..c5535701 100644
--- a/IGC/Compiler/HandleLoadStoreInstructions.cpp
+++ b/IGC/Compiler/HandleLoadStoreInstructions.cpp
@@ -77,7 +77,7 @@ void HandleLoadStoreInstructions::visitLoadInst(llvm::LoadInst& I)
 
         if (I.getType()->isVectorTy())
         {
-            numVectorElements = (uint32_t)cast<VectorType>(I.getType())->getNumElements();
+            numVectorElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
             doubleDstType = IGCLLVM::FixedVectorType::get(builder.getDoubleTy(), numVectorElements);
         }
         uint as = ptrv->getType()->getPointerAddressSpace();
@@ -163,7 +163,7 @@ void HandleLoadStoreInstructions::visitStoreInst(llvm::StoreInst& I)
 
         if (I.getValueOperand()->getType()->isVectorTy())
         {
-            numVectorElements = (uint32_t)cast<VectorType>(I.getValueOperand()->getType())->getNumElements();
+            numVectorElements = (uint32_t)cast<IGCLLVM::FixedVectorType>(I.getValueOperand()->getType())->getNumElements();
         }
 
 
diff --git a/IGC/Compiler/LegalizationPass.cpp b/IGC/Compiler/LegalizationPass.cpp
index b651350b..9524a495 100644
--- a/IGC/Compiler/LegalizationPass.cpp
+++ b/IGC/Compiler/LegalizationPass.cpp
@@ -670,7 +670,7 @@ void Legalization::visitBitCastInst(llvm::BitCastInst& I)
         if (!isa<TruncInst>(pZ->getOperand(0)))
             return;
 
-        auto* pVecTy = cast<VectorType>(pZ->getDestTy());
+        auto* pVecTy = cast<IGCLLVM::FixedVectorType>(pZ->getDestTy());
         if (pVecTy->getNumElements() != 3)
             return;
 
@@ -765,7 +765,7 @@ void Legalization::visitSelectInst(SelectInst& I)
     }
     else if (I.getType()->isVectorTy())
     {
-        unsigned int vecSize = (unsigned)cast<VectorType>(I.getType())->getNumElements();
+        unsigned int vecSize = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements();
         Value* newVec = UndefValue::get(I.getType());
         m_builder->SetInsertPoint(&I);
         for (unsigned int i = 0; i < vecSize; i++)
@@ -1147,7 +1147,7 @@ void Legalization::visitStoreInst(StoreInst& I)
     if (ConstantDataVector * vec = dyn_cast<ConstantDataVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementAsConstant(i);
@@ -1168,7 +1168,7 @@ void Legalization::visitStoreInst(StoreInst& I)
     else if (ConstantVector * vec = dyn_cast<ConstantVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getOperand(i);
@@ -1189,7 +1189,7 @@ void Legalization::visitStoreInst(StoreInst& I)
     else if (ConstantAggregateZero * vec = dyn_cast<ConstantAggregateZero>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementValue(i);
@@ -1340,7 +1340,7 @@ void Legalization::visitInsertElementInst(InsertElementInst& I)
     if (ConstantDataVector * vec = dyn_cast<ConstantDataVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(vec->getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementAsConstant(i);
@@ -1360,7 +1360,7 @@ void Legalization::visitInsertElementInst(InsertElementInst& I)
     else if (ConstantVector * vec = dyn_cast<ConstantVector>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(I.getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getOperand(i);
@@ -1380,7 +1380,7 @@ void Legalization::visitInsertElementInst(InsertElementInst& I)
     else if (ConstantAggregateZero * vec = dyn_cast<ConstantAggregateZero>(I.getOperand(0)))
     {
         Value* newVec = UndefValue::get(I.getType());
-        unsigned int nbElement = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
         for (unsigned int i = 0; i < nbElement; i++)
         {
             Constant* cst = vec->getElementValue(i);
@@ -1397,7 +1397,7 @@ void Legalization::visitInsertElementInst(InsertElementInst& I)
     else if (I.getOperand(1)->getType()->isIntegerTy(1))
     {
         // This promotes i1 insertelement to i32
-        unsigned int nbElement = (unsigned)cast<VectorType>(I.getOperand(0)->getType())->getNumElements();
+        unsigned int nbElement = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getOperand(0)->getType())->getNumElements();
         Value* newVec = UndefValue::get(IGCLLVM::FixedVectorType::get(m_builder->getInt32Ty(), nbElement));
         PromoteInsertElement(&I, newVec);
     }
@@ -1410,7 +1410,7 @@ void Legalization::visitShuffleVectorInst(ShuffleVectorInst& I)
     // If the original vector is a constant, just use the scalar constant,
     // otherwise extract from the original vector.
 
-    VectorType* resType = cast<VectorType>(I.getType());
+    IGCLLVM::FixedVectorType* resType = cast<IGCLLVM::FixedVectorType>(I.getType());
     Value* newVec = UndefValue::get(resType);
     Value* src0 = I.getOperand(0);
     Value* src1 = I.getOperand(1);
@@ -1421,7 +1421,7 @@ void Legalization::visitShuffleVectorInst(ShuffleVectorInst& I)
     Constant* mask = I.getShuffleMaskForBitcode();
 #endif
     // The two inputs are guaranteed to be of the same type
-    VectorType* inType = cast<VectorType>(src0->getType());
+    IGCLLVM::FixedVectorType* inType = cast<IGCLLVM::FixedVectorType>(src0->getType());
     int inCount = int_cast<int>(inType->getNumElements());
     int inBase = 2;  // 2 means using undef
     // if inType == resType, use src0/src1 as the input
@@ -1637,7 +1637,7 @@ Type* Legalization::LegalAllocaType(Type* type) const
 #endif
         legalType = IGCLLVM::FixedVectorType::get(
             LegalAllocaType(cast<VectorType>(type)->getElementType()),
-            (unsigned)cast<VectorType>(type)->getNumElements());
+            (unsigned)cast<IGCLLVM::FixedVectorType>(type)->getNumElements());
         break;
     case Type::StructTyID:
         return LegalStructAllocaType(type);
@@ -1937,7 +1937,7 @@ void Legalization::visitIntrinsicInst(llvm::IntrinsicInst& I)
         Value* newValue = nullptr;
         if (srcType->isVectorTy())
         {
-            auto sourceVT = cast<VectorType>(srcType);
+            auto sourceVT = cast<IGCLLVM::FixedVectorType>(srcType);
             const unsigned int numElements = (uint32_t)sourceVT->getNumElements();
             Value* dstVec = UndefValue::get(srcType);
             for (unsigned int i = 0; i < numElements; ++i)
@@ -2081,7 +2081,7 @@ void Legalization::visitTruncInst(llvm::TruncInst& I) {
     }
 
     Src = BC->getOperand(0);
-    VectorType* VTy = dyn_cast<VectorType>(Src->getType());
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Src->getType());
     // Bail out if it's not bitcasted from <3 x i16>
     if (!VTy || VTy->getNumElements() != 3 || !VTy->getElementType()->isIntegerTy(16))
         return;
diff --git a/IGC/Compiler/Legalizer/InstPromoter.cpp b/IGC/Compiler/Legalizer/InstPromoter.cpp
index bba1d96d..8fadf89f 100644
--- a/IGC/Compiler/Legalizer/InstPromoter.cpp
+++ b/IGC/Compiler/Legalizer/InstPromoter.cpp
@@ -25,6 +25,7 @@ IN THE SOFTWARE.
 #define DEBUG_TYPE "type-legalizer"
 #include "TypeLegalizer.h"
 #include "InstPromoter.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/MathExtras.h"
@@ -394,10 +395,16 @@ bool InstPromoter::visitBitCastInst(BitCastInst& I) {
         unsigned N =
             Val->getType()->getScalarSizeInBits() / DestTy->getScalarSizeInBits();
         Value* BC =
-            IRB->CreateBitCast(Val, VectorType::get(DestTy->getScalarType(), N));
+            IRB->CreateBitCast(Val, IGCLLVM::FixedVectorType::get(DestTy->getScalarType(), N));
 
         std::vector<Constant*> Vals;
-        for (unsigned i = 0; i < DestTy->getVectorNumElements(); i++)
+        for (unsigned i = 0;
+#if LLVM_VERSION_MAJOR >= 12
+             i < cast<IGCLLVM::FixedVectorType>(DestTy)->getNumElements();
+#else
+             i < DestTy->getVectorNumElements();
+#endif
+             i++)
             Vals.push_back(IRB->getInt32(i));
 
         Value* Mask = ConstantVector::get(Vals);
diff --git a/IGC/Compiler/Legalizer/InstScalarizer.cpp b/IGC/Compiler/Legalizer/InstScalarizer.cpp
index 3902f740..c8e18cc5 100644
--- a/IGC/Compiler/Legalizer/InstScalarizer.cpp
+++ b/IGC/Compiler/Legalizer/InstScalarizer.cpp
@@ -130,7 +130,7 @@ bool InstScalarizer::visitLoadInst(LoadInst& I) {
         // otherwise, it's broken.
         IGC_ASSERT(TL->getTypeSizeInBits(EltTy) == TL->getTypeStoreSizeInBits(EltTy));
 
-        unsigned NumElts = (unsigned)cast<VectorType>(OrigTy)->getNumElements();
+        unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(OrigTy)->getNumElements();
         unsigned Elt = 0;
 
         Type* NewPtrTy = PointerType::get(EltTy, AS);
@@ -268,7 +268,7 @@ bool InstScalarizer::visitStoreInst(StoreInst& I) {
         // otherwise, it's broken.
         IGC_ASSERT(TL->getTypeSizeInBits(EltTy) == TL->getTypeStoreSizeInBits(EltTy));
 
-        unsigned NumElts = (unsigned)cast<VectorType>(OrigTy)->getNumElements();
+        unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(OrigTy)->getNumElements();
         unsigned Elt = 0;
 
         Type* NewPtrTy = PointerType::get(EltTy, AS);
@@ -498,7 +498,7 @@ bool InstScalarizer::visitInsertElementInst(InsertElementInst& I) {
     IGC_ASSERT(EltSeq->size());
     IGC_ASSERT(VecSeqCopy.size() % EltSeq->size() == 0);
 
-    unsigned NumElts = (unsigned)cast<VectorType>(I.getOperand(0)->getType())->getNumElements();
+    unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(I.getOperand(0)->getType())->getNumElements();
     unsigned i = 0;
     for (unsigned Elt = 0; Elt != NumElts; ++Elt) {
         if (Elt == Idx) {
diff --git a/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp b/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp
index 28f8ce84..778132c4 100644
--- a/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp
+++ b/IGC/Compiler/Legalizer/PeepholeTypeLegalizer.cpp
@@ -162,7 +162,7 @@ void PeepholeTypeLegalizer::legalizePhiInstruction(Instruction& I)
 
     if (quotient > 1)
     {
-        unsigned numElements = I.getType()->isVectorTy() ? (unsigned)cast<VectorType>(I.getType())->getNumElements() : 1;
+        unsigned numElements = I.getType()->isVectorTy() ? (unsigned)cast<IGCLLVM::FixedVectorType>(I.getType())->getNumElements() : 1;
         Type* newType = IGCLLVM::FixedVectorType::get(Type::getIntNTy(I.getContext(), promoteToInt), quotient * numElements);
 
         PHINode* newPhi = m_builder->CreatePHI(newType, oldPhi->getNumIncomingValues());
@@ -223,7 +223,7 @@ void PeepholeTypeLegalizer::legalizeExtractElement(Instruction& I)
     unsigned elementWidth = extract->getType()->getScalarSizeInBits();
     if (!isLegalInteger(elementWidth) && extract->getType()->isIntOrIntVectorTy())
     {
-        unsigned numElements = (unsigned)cast<VectorType>(extract->getOperand(0)->getType())->getNumElements();
+        unsigned numElements = (unsigned)cast<IGCLLVM::FixedVectorType>(extract->getOperand(0)->getType())->getNumElements();
         unsigned quotient, promoteToInt;
         promoteInt(elementWidth, quotient, promoteToInt, DL->getLargestLegalIntTypeSizeInBits());
 
@@ -850,7 +850,7 @@ void PeepholeTypeLegalizer::cleanupZExtInst(Instruction& I) {
         }
 
         unsigned ipElmtSize = prevInst->getOperand(0)->getType()->getScalarSizeInBits();
-        unsigned ipVecSize = (unsigned)cast<VectorType>(prevInst->getOperand(0)->getType())->getNumElements();
+        unsigned ipVecSize = (unsigned)cast<IGCLLVM::FixedVectorType>(prevInst->getOperand(0)->getType())->getNumElements();
         unsigned convFactor = promoteToInt / ipElmtSize;
 
         Value* vecRes = UndefValue::get(IGCLLVM::FixedVectorType::get(llvm::Type::getIntNTy(I.getContext(), promoteToInt), quotient));
diff --git a/IGC/Compiler/Legalizer/TypeLegalizer.cpp b/IGC/Compiler/Legalizer/TypeLegalizer.cpp
index f8f71d71..a46f42bd 100644
--- a/IGC/Compiler/Legalizer/TypeLegalizer.cpp
+++ b/IGC/Compiler/Legalizer/TypeLegalizer.cpp
@@ -32,6 +32,7 @@ IN THE SOFTWARE.
 #include "InstScalarizer.h"
 #include "InstElementizer.h"
 #include "common/LLVMWarningsPush.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvm/ADT/PostOrderIterator.h"
 #include "llvm/IR/CFG.h"
 #include "llvm/Support/Debug.h"
@@ -290,7 +291,7 @@ TypeSeq* TypeLegalizer::getScalarizedTypeSeq(Type* Ty) {
     }
 
     Type* EltTy = cast<VectorType>(Ty)->getElementType();
-    for (unsigned i = 0, e = (unsigned)cast<VectorType>(Ty)->getNumElements(); i != e; ++i)
+    for (unsigned i = 0, e = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements(); i != e; ++i)
         TMI->second.push_back(EltTy);
 
     return &TMI->second;
diff --git a/IGC/Compiler/Legalizer/TypeLegalizer.h b/IGC/Compiler/Legalizer/TypeLegalizer.h
index f3ce264c..a6910d08 100644
--- a/IGC/Compiler/Legalizer/TypeLegalizer.h
+++ b/IGC/Compiler/Legalizer/TypeLegalizer.h
@@ -28,6 +28,7 @@ IN THE SOFTWARE.
 #include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/Analysis/InlineCost.h"
 #include "llvmWrapper/IR/InstrTypes.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/Support/Alignment.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/DenseMap.h"
@@ -287,7 +288,7 @@ namespace IGC {
                 if (!Ty->isVectorTy())
                     return false;
 
-                unsigned NumElts = (unsigned)cast<VectorType>(Ty)->getNumElements();
+                unsigned NumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements();
                 Type* EltTy = cast<VectorType>(Ty)->getElementType();
                 const auto& ProfitLengths = getProfitLoadVectorLength(EltTy);
 
diff --git a/IGC/Compiler/LowPrecisionOptPass.cpp b/IGC/Compiler/LowPrecisionOptPass.cpp
index 64912719..1d1db949 100644
--- a/IGC/Compiler/LowPrecisionOptPass.cpp
+++ b/IGC/Compiler/LowPrecisionOptPass.cpp
@@ -252,7 +252,7 @@ bool LowPrecisionOpt::propagateSamplerType(llvm::GenIntrinsicInst& I)
         return false;
     }
 
-    VectorType* oldTy = cast<VectorType>(I.getType());
+    IGCLLVM::FixedVectorType* oldTy = cast<IGCLLVM::FixedVectorType>(I.getType());
     llvm::SmallVector<llvm::Type*, 4> overloadTys;
     auto retTy = IGCLLVM::FixedVectorType::get(newDstType, int_cast<unsigned int>(oldTy->getNumElements()));
     overloadTys.push_back(retTy);
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.cpp
index 393b4b0a..e9c07b34 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.cpp
@@ -23,6 +23,8 @@ IN THE SOFTWARE.
 ============================= end_copyright_notice ===========================*/
 
 #include "llvm/Config/llvm-config.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
+#include "llvmWrapper/Analysis/TargetLibraryInfo.h"
 #include "Compiler/Optimizer/OpenCLPasses/AddressSpaceAliasAnalysis/AddressSpaceAliasAnalysis.h"
 #include "Compiler/CodeGenPublic.h"
 #include "Compiler/IGCPassSupport.h"
@@ -178,12 +180,11 @@ namespace {
         bool doInitialization(Module& M) override {
             if(M.size() > 0)
             {
-                Result.reset(new AddressSpaceAAResult(
-                getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(
 #if LLVM_VERSION_MAJOR >= 10
-                    *M.begin()
+                Function &F = *M.begin();
 #endif
-                    ),
+                Result.reset(new AddressSpaceAAResult(
+                getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(),
                     *getAnalysis<CodeGenContextWrapper>().getCodeGenContext()));
             }
             return false;
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp
index 67535cfc..3cdd2975 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.cpp
@@ -24,6 +24,7 @@ IN THE SOFTWARE.
 
 #include "Compiler/Optimizer/OpenCLPasses/AggregateArguments/AggregateArguments.hpp"
 #include "Compiler/IGCPassSupport.h"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/IR/Function.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -130,7 +131,7 @@ static uint64_t getNumElements(Type* type)
     {
         return arrayType->getNumElements();
     }
-    if (VectorType * vectorType = dyn_cast<VectorType>(type))
+    if (IGCLLVM::FixedVectorType * vectorType = dyn_cast<IGCLLVM::FixedVectorType>(type))
     {
         return vectorType->getNumElements();
     }
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp
index 2a9d7499..79ed0948 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/CorrectlyRoundedDivSqrt/CorrectlyRoundedDivSqrt.cpp
@@ -27,6 +27,7 @@ IN THE SOFTWARE.
 #include "Compiler/IGCPassSupport.h"
 #include "GenISAIntrinsics/GenIntrinsicInst.h"
 
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/IR/Function.h>
 #include <llvm/IR/Instructions.h>
@@ -133,7 +134,7 @@ Value* CorrectlyRoundedDivSqrt::emitIEEEDivide(BinaryOperator* I, Value* Op0, Va
     }
     else
     {
-        auto vType = dyn_cast<VectorType>(Ty);
+        auto vType = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
         unsigned VecLen = (uint32_t)vType->getNumElements();
         Divide = UndefValue::get(Ty);
         for (unsigned i = 0; i < VecLen; i++)
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
index c5ff3ac0..119520ed 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
@@ -952,7 +952,11 @@ namespace //Anonymous
         {
             auto ndrangeStructName = "struct.ndrange_t";
             auto module = _deviceExecCall->getModule();
+#if LLVM_VERSION_MAJOR >= 12
+            auto ndrangeTy = llvm::StructType::getTypeByName(module->getContext(), ndrangeStructName);
+#else
             auto ndrangeTy = module->getTypeByName(ndrangeStructName);
+#endif
             if (ndrangeTy == nullptr)
             {
                 //create struct type
@@ -1697,7 +1701,7 @@ namespace //Anonymous
                     // this generates <element_type><num_elements> string. Ie for char2 element_type is char and num_elements is 2
                     // that is done by callin BaseTypeName on vector element type, this recursive call has only a depth of one since
                     // there are no compound vectors in OpenCL.
-                    auto vType = llvm::dyn_cast<VectorType>(type);
+                    auto vType = llvm::dyn_cast<IGCLLVM::FixedVectorType>(type);
                     return BaseTypeName(type->getContainedType(0), os) << vType->getNumElements();
                 }
                 default:
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp
index 6448463d..7df71079 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/KernelArgs.cpp
@@ -24,6 +24,7 @@ IN THE SOFTWARE.
 
 #include "Compiler/Optimizer/OpenCLPasses/KernelArgs.hpp"
 #include "AdaptorCommon/ImplicitArgs.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/IR/Argument.h>
 #include <llvm/IR/DataLayout.h>
@@ -388,7 +389,7 @@ unsigned int KernelArg::calcAssociatedArgNo(const ImplicitArg& implicitArg, cons
 
 unsigned int KernelArg::getNumComponents() const
 {
-    if (VectorType * vecType = dyn_cast<VectorType>(m_arg->getType()))
+    if (IGCLLVM::FixedVectorType * vecType = dyn_cast<IGCLLVM::FixedVectorType>(m_arg->getType()))
     {
         // Vector
         return int_cast<unsigned int>(vecType->getNumElements());
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
index c7414b8e..74964510 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
@@ -719,7 +719,7 @@ Value* OpenCLPrintfResolution::fixupPrintfArg(CallInst& printfCall, Value* arg,
             }
 
             Type* newType = Type::getFloatTy(arg->getContext());
-            if (auto argVT = dyn_cast<VectorType>(arg->getType()))
+            if (auto argVT = dyn_cast<IGCLLVM::FixedVectorType>(arg->getType()))
             {
                 newType = IGCLLVM::FixedVectorType::get(newType, (unsigned)argVT->getNumElements());
             }
@@ -749,7 +749,7 @@ void OpenCLPrintfResolution::preprocessPrintfArgs(CallInst& printfCall)
         IGC::SHADER_PRINTF_TYPE argDataType = getPrintfArgDataType(arg);
         arg = fixupPrintfArg(printfCall, arg, argDataType);
         uint vecSize = 0;
-        if (auto argVType = dyn_cast<VectorType>(argType)) {
+        if (auto argVType = dyn_cast<IGCLLVM::FixedVectorType>(argType)) {
             vecSize = (uint)argVType->getNumElements();
         }
         m_argDescriptors.push_back(SPrintfArgDescriptor(argDataType, arg, vecSize));
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp
index 2ed5a2b6..07f85f4c 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.cpp
@@ -29,6 +29,7 @@ IN THE SOFTWARE.
 #include "Compiler/IGCPassSupport.h"
 #include "Compiler/CISACodeGen/GenCodeGenModule.h"
 #include "Compiler/CISACodeGen/LowerGEPForPrivMem.hpp"
+#include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/Transforms/Utils/Local.h"
 #include "llvm/IR/DataLayout.h"
@@ -604,7 +605,7 @@ public:
             Type* scalarptrTy = PointerType::get(scalarType, pLoad->getPointerAddressSpace());
             IGC_ASSERT(scalarType->getPrimitiveSizeInBits() / 8 == elementSize);
             Value* vec = UndefValue::get(pLoad->getType());
-            auto pLoadVT = cast<VectorType>(pLoad->getType());
+            auto pLoadVT = cast<IGCLLVM::FixedVectorType>(pLoad->getType());
             for (unsigned i = 0, e = (unsigned)pLoadVT->getNumElements(); i < e; ++i)
             {
                 Value* ptr = IRB.CreateIntToPtr(address, scalarptrTy);
@@ -643,7 +644,7 @@ public:
             IGC_ASSERT(scalarType->getPrimitiveSizeInBits() / 8 == elementSize);
             Value* vec = pStore->getValueOperand();
 
-            unsigned vecNumElts = (unsigned)cast<VectorType>(vec->getType())->getNumElements();
+            unsigned vecNumElts = (unsigned)cast<IGCLLVM::FixedVectorType>(vec->getType())->getNumElements();
             for (unsigned i = 0; i < vecNumElts; ++i)
             {
                 Value* ptr = IRB.CreateIntToPtr(address, scalarptrTy);
@@ -707,7 +708,7 @@ bool PrivateMemoryResolution::testTransposedMemory(const Type* pTmpType, const T
         }
         else if(pTmpType->isVectorTy())
         {
-            auto pTmpVType = cast<VectorType>(pTmpType);
+            auto pTmpVType = cast<IGCLLVM::FixedVectorType>(pTmpType);
             tmpAllocaSize *= pTmpVType->getNumElements();
             pTmpType = pTmpType->getContainedType(0);
             ok = (nullptr != pTmpType);
@@ -815,7 +816,11 @@ bool PrivateMemoryResolution::resolveAllocaInstructions(bool privateOnStack)
     // Construct an empty DebugLoc.
     IF_DEBUG_INFO(DebugLoc entryDebugLoc);
     // Assign with the function location if available.
+#if LLVM_VERSION_MAJOR >= 12
+    IF_DEBUG_INFO_IF(DISubprogram *subprogram = m_currFunction->getSubprogram(), entryDebugLoc = DILocation::get(subprogram->getContext(), subprogram->getLine(), 0, subprogram););
+#else
     IF_DEBUG_INFO_IF(DISubprogram *subprogram = m_currFunction->getSubprogram(), entryDebugLoc = DebugLoc::get(subprogram->getLine(), 0, subprogram););
+#endif
     IF_DEBUG_INFO(entryBuilder.SetCurrentDebugLocation(entryDebugLoc));
 
     if (privateOnStack)
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
index c8414efa..68491d48 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
@@ -254,7 +254,7 @@ Instruction* ReplaceUnsupportedIntrinsics::insertLoop(Instruction* Loc, Value* L
 Value* ReplaceUnsupportedIntrinsics::replicateScalar(
     Value* ScalarVal, Type* Ty, Instruction* InsertBefore)
 {
-    VectorType* VTy = dyn_cast<VectorType>(Ty);
+    IGCLLVM::FixedVectorType* VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
     Type* ETy = VTy ? VTy->getElementType() : Ty;
     uint32_t sBits = (unsigned int)ScalarVal->getType()->getPrimitiveSizeInBits();
     uint32_t nBits = (unsigned int)ETy->getPrimitiveSizeInBits();
@@ -868,7 +868,7 @@ void ReplaceUnsupportedIntrinsics::replaceFunnelShift(IntrinsicInst* I) {
     }
 
     Value* numBits = Builder.getIntN(sizeInBits, sizeInBits);
-    if (auto IVT = dyn_cast<VectorType>(I->getType())) {
+    if (auto IVT = dyn_cast<IGCLLVM::FixedVectorType>(I->getType())) {
         numBits = ConstantVector::getSplat(IGCLLVM::getElementCount((uint32_t)IVT->getNumElements()), cast<Constant>(numBits));
     }
     auto shiftModulo = Builder.CreateURem(I->getArgOperand(2), numBits);
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
index 7188cc50..535d6268 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
@@ -303,7 +303,11 @@ static Value* BuildLoadInst(CallInst& CI, unsigned int Offset, Type* DataType)
     auto Size = ElemByteSize;
     if (DataType->isVectorTy())
     {
+#if LLVM_VERSION_MAJOR >= 12
+        Size *= cast<IGCLLVM::FixedVectorType>(DataType)->getNumElements();
+#else
         Size *= DataType->getVectorNumElements();
+#endif
     }
     unsigned int AlignedOffset = (Offset / ElemByteSize) * ElemByteSize;
     unsigned int LoadByteSize = (Offset == AlignedOffset) ? Size : Size * 2;
diff --git a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
index 1fda21d5..63a22864 100644
--- a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
@@ -340,7 +340,7 @@ bool PreCompiledFuncImport::preProcessDouble()
                     }
                     else
                     {
-                        uint32_t vectorSize = cast<VectorType>(Inst->getType())->getNumElements();
+                        uint32_t vectorSize = cast<IGCLLVM::FixedVectorType>(Inst->getType())->getNumElements();
                         fsub = llvm::UndefValue::get(Inst->getType());
 
                         for (uint32_t i = 0; i < vectorSize; ++i)
@@ -936,7 +936,7 @@ void PreCompiledFuncImport::processDivide(BinaryOperator& inst, EmulatedFunction
 
     Type* argumentType = inst.getOperand(0)->getType();
 
-    if (auto argumentVType = dyn_cast<VectorType>(argumentType))
+    if (auto argumentVType = dyn_cast<IGCLLVM::FixedVectorType>(argumentType))
     {
         numElements = (unsigned)argumentVType->getNumElements();
     }
diff --git a/IGC/Compiler/Optimizer/Scalarizer.cpp b/IGC/Compiler/Optimizer/Scalarizer.cpp
index 4f59eaf9..a4e73a6d 100644
--- a/IGC/Compiler/Optimizer/Scalarizer.cpp
+++ b/IGC/Compiler/Optimizer/Scalarizer.cpp
@@ -289,7 +289,7 @@ void ScalarizeFunction::scalarizeInstruction(BinaryOperator* BI)
 {
     V_PRINT(scalarizer, "\t\tBinary instruction\n");
     IGC_ASSERT_MESSAGE(BI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(BI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(BI->getType());
     // Only need handling for vector binary ops
     if (!instType) return;
 
@@ -349,7 +349,7 @@ void ScalarizeFunction::scalarizeInstruction(CmpInst* CI)
 {
     V_PRINT(scalarizer, "\t\tCompare instruction\n");
     IGC_ASSERT_MESSAGE(CI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(CI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getType());
     // Only need handling for vector compares
     if (!instType) return;
 
@@ -397,13 +397,13 @@ void ScalarizeFunction::scalarizeInstruction(CastInst* CI)
 {
     V_PRINT(scalarizer, "\t\tCast instruction\n");
     IGC_ASSERT_MESSAGE(CI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(CI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getType());
 
     // For BitCast - we only scalarize if src and dst types have same vector length
     if (isa<BitCastInst>(CI))
     {
         if (!instType) return recoverNonScalarizableInst(CI);
-        VectorType* srcType = dyn_cast<VectorType>(CI->getOperand(0)->getType());
+        IGCLLVM::FixedVectorType* srcType = dyn_cast<IGCLLVM::FixedVectorType>(CI->getOperand(0)->getType());
         if (!srcType || (instType->getNumElements() != srcType->getNumElements()))
         {
             return recoverNonScalarizableInst(CI);
@@ -458,7 +458,7 @@ void ScalarizeFunction::scalarizeInstruction(PHINode* PI)
 {
     V_PRINT(scalarizer, "\t\tPHI instruction\n");
     IGC_ASSERT_MESSAGE(PI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(PI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(PI->getType());
     // Only need handling for vector PHI
     if (!instType) return;
 
@@ -569,7 +569,7 @@ void ScalarizeFunction::scalarizeInstruction(SelectInst* SI)
 {
     V_PRINT(scalarizer, "\t\tSelect instruction\n");
     IGC_ASSERT_MESSAGE(SI, "instruction type dynamic cast failed");
-    VectorType* instType = dyn_cast<VectorType>(SI->getType());
+    IGCLLVM::FixedVectorType* instType = dyn_cast<IGCLLVM::FixedVectorType>(SI->getType());
     // Only need handling for vector select
     if (!instType) return;
 
@@ -651,7 +651,7 @@ void ScalarizeFunction::scalarizeInstruction(ExtractElementInst* EI)
 
     // Connect the "extracted" value to all its consumers
     uint64_t scalarIndex = cast<ConstantInt>(scalarIndexVal)->getZExtValue();
-    auto valueVType = cast<VectorType>(vectorValue->getType());
+    auto valueVType = cast<IGCLLVM::FixedVectorType>(vectorValue->getType());
     if (static_cast<unsigned int>(scalarIndex) < (unsigned)valueVType->getNumElements())
     {
         IGC_ASSERT_MESSAGE(NULL != operand[static_cast<unsigned int>(scalarIndex)], "SCM error");
@@ -715,7 +715,7 @@ void ScalarizeFunction::scalarizeInstruction(InsertElementInst* II)
     if (isa<UndefValue>(sourceVectorValue))
     {
         // Scalarize the undef value (generate a scalar undef)
-        VectorType* inputVectorType = dyn_cast<VectorType>(sourceVectorValue->getType());
+        IGCLLVM::FixedVectorType* inputVectorType = dyn_cast<IGCLLVM::FixedVectorType>(sourceVectorValue->getType());
         IGC_ASSERT_MESSAGE(inputVectorType, "expected vector argument");
 
         UndefValue* undefVal = UndefValue::get(inputVectorType->getElementType());
@@ -756,7 +756,7 @@ void ScalarizeFunction::scalarizeInstruction(ShuffleVectorInst* SI)
     IGC_ASSERT(nullptr != sourceVector0Value);
     Value* sourceVector1Value = SI->getOperand(1);
     IGC_ASSERT(nullptr != sourceVector1Value);
-    VectorType* const inputType = dyn_cast<VectorType>(sourceVector0Value->getType());
+    IGCLLVM::FixedVectorType* const inputType = dyn_cast<IGCLLVM::FixedVectorType>(sourceVector0Value->getType());
     IGC_ASSERT_MESSAGE(nullptr != inputType, "vector input error");
     IGC_ASSERT_MESSAGE(inputType == sourceVector1Value->getType(), "vector input error");
     unsigned sourceVectorWidth = int_cast<unsigned>(inputType->getNumElements());
@@ -778,7 +778,7 @@ void ScalarizeFunction::scalarizeInstruction(ShuffleVectorInst* SI)
 
     // Generate array for shuffled scalar values
     SmallVector<Value*, MAX_INPUT_VECTOR_WIDTH>newVector;
-    unsigned width = int_cast<unsigned>(SI->getType()->getNumElements());
+    unsigned width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(SI->getType())->getNumElements());
 
     // Generate undef value, which may be needed as some scalar elements
     UndefValue* undef = UndefValue::get(inputType->getElementType());
@@ -847,7 +847,7 @@ void ScalarizeFunction::scalarizeInstruction(GetElementPtrInst* GI)
 
     if (baseValue->getType()->isVectorTy())
     {
-        width = int_cast<unsigned>(dyn_cast<VectorType>(baseValue->getType())->getNumElements());
+        width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(baseValue->getType())->getNumElements());
         // Obtain the scalarized operands
         obtainScalarizedValues(operand1, NULL, baseValue, GI);
         ptrTy = dyn_cast<VectorType>(baseValue->getType())->getElementType();
@@ -858,7 +858,7 @@ void ScalarizeFunction::scalarizeInstruction(GetElementPtrInst* GI)
     }
     if (indexValue->getType()->isVectorTy())
     {
-        width = int_cast<unsigned>(dyn_cast<VectorType>(indexValue->getType())->getNumElements());
+        width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(indexValue->getType())->getNumElements());
         // Obtain the scalarized operands
         obtainScalarizedValues(operand2, NULL, indexValue, GI);
     }
@@ -897,7 +897,7 @@ void ScalarizeFunction::scalarizeInstruction(LoadInst* LI)
     V_PRINT(scalarizer, "\t\tLoad instruction\n");
     IGC_ASSERT_MESSAGE(LI, "instruction type dynamic cast failed");
 
-    VectorType* dataType = dyn_cast<VectorType>(LI->getType());
+    IGCLLVM::FixedVectorType* dataType = dyn_cast<IGCLLVM::FixedVectorType>(LI->getType());
     if (isScalarizableLoadStoreType(dataType) && m_pDL)
     {
         // Prepare empty SCM entry for the instruction
@@ -969,7 +969,7 @@ void ScalarizeFunction::scalarizeInstruction(StoreInst* SI)
 
     int indexPtr = SI->getPointerOperandIndex();
     int indexData = 1 - indexPtr;
-    VectorType* dataType = dyn_cast<VectorType>(SI->getOperand(indexData)->getType());
+    IGCLLVM::FixedVectorType* dataType = dyn_cast<IGCLLVM::FixedVectorType>(SI->getOperand(indexData)->getType());
     if (isScalarizableLoadStoreType(dataType) && m_pDL)
     {
         // Get additional info from instruction
@@ -1040,7 +1040,7 @@ void ScalarizeFunction::obtainScalarizedValues(SmallVectorImpl<Value*>& retValue
 {
     V_PRINT(scalarizer, "\t\t\tObtaining scalar value... " << *origValue << "\n");
 
-    VectorType* origType = dyn_cast<VectorType>(origValue->getType());
+    IGCLLVM::FixedVectorType* origType = dyn_cast<IGCLLVM::FixedVectorType>(origValue->getType());
     IGC_ASSERT_MESSAGE(origType, "Value must have a vector type!");
     unsigned width = int_cast<unsigned>(origType->getNumElements());
 
@@ -1202,7 +1202,7 @@ void ScalarizeFunction::obtainVectorValueWhichMightBeScalarizedImpl(Value* vecto
     }
 
     Value* assembledVector = UndefValue::get(vectorVal->getType());
-    unsigned width = int_cast<unsigned>(dyn_cast<VectorType>(vectorVal->getType())->getNumElements());
+    unsigned width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(vectorVal->getType())->getNumElements());
     for (unsigned i = 0; i < width; i++)
     {
         IGC_ASSERT_MESSAGE(NULL != valueEntry->scalarValues[i], "SCM entry has NULL value");
@@ -1262,7 +1262,7 @@ void ScalarizeFunction::updateSCMEntryWithValues(ScalarizeFunction::SCMEntry* en
     bool matchDbgLoc)
 {
     IGC_ASSERT_MESSAGE((origValue->getType()->isArrayTy() || origValue->getType()->isVectorTy()), "only Vector values are supported");
-    unsigned width = int_cast<unsigned>(dyn_cast<VectorType>(origValue->getType())->getNumElements());
+    unsigned width = int_cast<unsigned>(dyn_cast<IGCLLVM::FixedVectorType>(origValue->getType())->getNumElements());
 
     entry->isOriginalVectorRemoved = isOrigValueRemoved;
 
@@ -1326,7 +1326,7 @@ void ScalarizeFunction::resolveDeferredInstructions()
         Instruction* vectorInst = dyn_cast<Instruction>(current.unresolvedInst);
         IGC_ASSERT_MESSAGE(vectorInst, "DRL only handles unresolved instructions");
 
-        VectorType* currType = dyn_cast<VectorType>(vectorInst->getType());
+        IGCLLVM::FixedVectorType* currType = dyn_cast<IGCLLVM::FixedVectorType>(vectorInst->getType());
         IGC_ASSERT_MESSAGE(currType, "Cannot have DRL of non-vector value");
         unsigned width = int_cast<unsigned>(currType->getNumElements());
 
diff --git a/IGC/Compiler/Optimizer/ValueTracker.cpp b/IGC/Compiler/Optimizer/ValueTracker.cpp
index c06f7312..d8f0d385 100644
--- a/IGC/Compiler/Optimizer/ValueTracker.cpp
+++ b/IGC/Compiler/Optimizer/ValueTracker.cpp
@@ -178,7 +178,7 @@ Value* ValueTracker::handleExtractElement(ExtractElementInst* E)
         {
             auto mask = I->getShuffleMask();
             uint shuffleidx = int_cast<uint>(mask[(uint)idx]);
-            auto vType = dyn_cast<VectorType>(I->getOperand(0)->getType());
+            auto vType = dyn_cast<IGCLLVM::FixedVectorType>(I->getOperand(0)->getType());
             baseValue = (shuffleidx < vType->getNumElements()) ?
                 I->getOperand(0) : I->getOperand(1);
         }
diff --git a/IGC/Compiler/VerificationPass.cpp b/IGC/Compiler/VerificationPass.cpp
index 98437d79..40d50f5a 100644
--- a/IGC/Compiler/VerificationPass.cpp
+++ b/IGC/Compiler/VerificationPass.cpp
@@ -302,7 +302,7 @@ bool VerificationPass::verifyType(Type* type, Value* val)
 
     case IGCLLVM::VectorTyID:
     {
-        auto VType = cast<VectorType>(type);
+        auto VType = cast<IGCLLVM::FixedVectorType>(type);
         unsigned typeSize = (unsigned)VType->getNumElements();
         if (!m_IGC_IR_spec.vectorTypeSizes.count(typeSize))
         {
diff --git a/IGC/DebugInfo/DebugInfoUtils.hpp b/IGC/DebugInfo/DebugInfoUtils.hpp
index 7f2e288a..b77a550d 100644
--- a/IGC/DebugInfo/DebugInfoUtils.hpp
+++ b/IGC/DebugInfo/DebugInfoUtils.hpp
@@ -108,7 +108,11 @@ namespace IGC
                 IGCLLVM::DIBuilder Builder(M);
                 llvm::DIGlobalVariable* GV = GVs[j]->getVariable();
                 llvm::DIScope* scopeToUse = GV->getScope();
+#if LLVM_VERSION_MAJOR >= 12
+                llvm::DILocation* locToUse = llvm::DILocation::get(scopeToUse->getContext(), GV->getLine(), 0, scopeToUse, loc);
+#else
                 llvm::DILocation* locToUse = llvm::DebugLoc::get(GV->getLine(), 0, scopeToUse, loc);
+#endif
                 if (llvm::isa<llvm::DICompileUnit>(GV->getScope()))
                 {
                     // Function has no DebugLoc so it is either internal
diff --git a/IGC/DebugInfo/DwarfDebug.cpp b/IGC/DebugInfo/DwarfDebug.cpp
index 683b83f7..bd9f17b7 100644
--- a/IGC/DebugInfo/DwarfDebug.cpp
+++ b/IGC/DebugInfo/DwarfDebug.cpp
@@ -2102,9 +2102,17 @@ static DebugLoc getFnDebugLoc(DebugLoc DL, const LLVMContext& Ctx)
         // Check for number of operands since the compatibility is cheap here.
         if (SP->getNumOperands() > 19)
         {
+#if LLVM_VERSION_MAJOR >= 12
+            return DILocation::get(SP->getContext(), SP->getScopeLine(), 0, SP);
+#else
             return DebugLoc::get(SP->getScopeLine(), 0, SP);
+#endif
         }
+#if LLVM_VERSION_MAJOR >= 12
+        return DILocation::get(SP->getContext(), SP->getLine(), 0, SP);
+#else
         return DebugLoc::get(SP->getLine(), 0, SP);
+#endif
     }
 
     return DebugLoc();
diff --git a/IGC/GenISAIntrinsics/GenIntrinsics.cpp b/IGC/GenISAIntrinsics/GenIntrinsics.cpp
index 708cfdaa..772155b2 100644
--- a/IGC/GenISAIntrinsics/GenIntrinsics.cpp
+++ b/IGC/GenISAIntrinsics/GenIntrinsics.cpp
@@ -204,7 +204,7 @@ static Type *DecodeFixedType(ArrayRef<GenISAIntrinsic::IITDescriptor> &Infos,
   case IITDescriptor::SameVecWidthArgument: {
     Type *EltTy = DecodeFixedType(Infos, Tys, Context);
     Type *Ty = Tys[D.getArgumentNumber()];
-    if (VectorType *VTy = dyn_cast<VectorType>(Ty)) {
+    if (IGCLLVM::FixedVectorType *VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty)) {
       return IGCLLVM::FixedVectorType::get(EltTy, int_cast<unsigned int>(VTy->getNumElements()));
     }
     IGC_ASSERT_EXIT_MESSAGE(0, "unhandled");
@@ -215,7 +215,7 @@ static Type *DecodeFixedType(ArrayRef<GenISAIntrinsic::IITDescriptor> &Infos,
   }
   case IITDescriptor::VecOfPtrsToElt: {
       Type *Ty = Tys[D.getArgumentNumber()];
-      VectorType *VTy = dyn_cast<VectorType>(Ty);
+      IGCLLVM::FixedVectorType *VTy = dyn_cast<IGCLLVM::FixedVectorType>(Ty);
       if (!VTy)
           IGC_ASSERT_EXIT_MESSAGE(0, "Expected an argument of Vector Type");
       Type *EltTy = cast<VectorType>(VTy)->getElementType();
@@ -434,7 +434,7 @@ static std::string getMangledTypeStr(Type* Ty) {
     Result += "f";
   }
   else if (isa<VectorType>(Ty))
-    Result += "v" + utostr(cast<VectorType>(Ty)->getNumElements()) +
+    Result += "v" + utostr(cast<IGCLLVM::FixedVectorType>(Ty)->getNumElements()) +
       getMangledTypeStr(cast<VectorType>(Ty)->getElementType());
   else if (Ty)
     Result += EVT::getEVT(Ty).getEVTString();
diff --git a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
index a89d63b9..a1bc5d2c 100644
--- a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
+++ b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
@@ -4929,7 +4929,7 @@ void LLVM3DBuilder<preserveNames, T, Inserter>::VectorToScalars(
     IGC_ASSERT(nullptr != vector->getType());
     IGC_ASSERT(vector->getType()->isVectorTy());
 
-    const unsigned count = (unsigned)llvm::cast<llvm::VectorType>(vector->getType())->getNumElements();
+    const unsigned count = (unsigned)llvm::cast<IGCLLVM::FixedVectorType>(vector->getType())->getNumElements();
     IGC_ASSERT(1 < count);
     IGC_ASSERT(count <= 4);
     IGC_ASSERT(count <= maxSize);
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h b/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h
index 08e5d6cf..30e29720 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Support/TypeSize.h
@@ -35,10 +35,16 @@ using namespace llvm;
 namespace IGCLLVM {
 #if LLVM_VERSION_MAJOR < 11
 inline unsigned getElementCount(unsigned EC) { return EC; }
-#else
+#elif LLVM_VERSION_MAJOR == 11
 inline ElementCount getElementCount(unsigned EC) {
   return ElementCount(EC, false);
 }
+#elif LLVM_VERSION_MAJOR  == 12
+inline ElementCount getElementCount(unsigned EC) {
+  return ElementCount::get(EC, false);
+}
+#else
+#error "unsupported LLVM version"
 #endif
 } // namespace IGCLLVM
 
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
index f6e54fb1..5266ee87 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
@@ -44,7 +44,7 @@ namespace IGCLLVM
     {
         return llvm::createLoopUnrollPass(OptLevel, false, Threshold, Count, AllowPartial, Runtime, UpperBound, AllowPeeling);
     }
-#elif LLVM_VERSION_MAJOR == 9 || LLVM_VERSION_MAJOR == 10 || LLVM_VERSION_MAJOR == 11
+#elif LLVM_VERSION_MAJOR >= 9 && LLVM_VERSION_MAJOR <= 12
     inline static llvm::Pass * createLoopUnrollPass(
         int OptLevel = 2, int Threshold = -1, int Count = -1,
         int AllowPartial = -1, int Runtime = -1,
@@ -52,7 +52,7 @@ namespace IGCLLVM
     {
         return llvm::createLoopUnrollPass(OptLevel, false, false, Threshold, Count, AllowPartial, Runtime, UpperBound, AllowPeeling);
     }
-#elif LLVM_VERSION_MAJOR >= 12
+#else
     //DO NOT assume same function signature for all incoming llvm versions! Double check to upgrade!
 #error Not supported llvm version.
 #endif
diff --git a/IGC/common/igc_resourceDimTypes.h b/IGC/common/igc_resourceDimTypes.h
index 6831b06c..d790330f 100644
--- a/IGC/common/igc_resourceDimTypes.h
+++ b/IGC/common/igc_resourceDimTypes.h
@@ -66,6 +66,11 @@ namespace IGC
             resourceDimTypeId == DIM_2D_TYPE || resourceDimTypeId == DIM_2D_ARRAY_TYPE ||
             resourceDimTypeId == DIM_3D_TYPE || resourceDimTypeId == DIM_CUBE_TYPE || resourceDimTypeId == DIM_CUBE_ARRAY_TYPE));
 
+#if LLVM_VERSION_MAJOR >= 12
+        llvm::LLVMContext& llvmCtx = module.getContext();
+        return llvm::StructType::getTypeByName(llvmCtx, ResourceDimensionTypeName[resourceDimTypeId]);
+#else
         return module.getTypeByName(ResourceDimensionTypeName[resourceDimTypeId]);
+#endif
     }
 }
\ No newline at end of file
-- 
2.17.1

