From ee1b87d107833e8803567cac438f55bde72d8e02 Mon Sep 17 00:00:00 2001
From: "Ung, Teng En" <teng.en.ung@intel.com>
Date: Mon, 30 Mar 2020 13:40:39 +0000
Subject: [PATCH 1/2] [hevcd] Enable the SPS/PPS error reporting

Issue:N/A
Test:sample_decode with mfxExtDecodeErrorReport

Upstream-Status: Accepted [https://github.com/Intel-Media-SDK/MediaSDK/pull/2383]

Signed-off-by: Ung, Teng En <teng.en.ung@intel.com>
---
 .../decode/h265/src/mfx_h265_dec_decode.cpp        | 10 ++++++
 .../umc/codec/h265_dec/src/umc_h265_mfx_utils.cpp  |  7 ++++
 .../codec/h265_dec/src/umc_h265_task_supplier.cpp  | 41 +++++++++++++++++++++-
 3 files changed, 57 insertions(+), 1 deletion(-)

diff --git a/_studio/mfx_lib/decode/h265/src/mfx_h265_dec_decode.cpp b/_studio/mfx_lib/decode/h265/src/mfx_h265_dec_decode.cpp
index 4ae164f..f346e8c 100644
--- a/_studio/mfx_lib/decode/h265/src/mfx_h265_dec_decode.cpp
+++ b/_studio/mfx_lib/decode/h265/src/mfx_h265_dec_decode.cpp
@@ -1105,6 +1105,16 @@ mfxStatus VideoDECODEH265::DecodeFrameCheck(mfxBitstream *bs, mfxFrameSurface1 *
 
         MFXMediaDataAdapter src(bs);
 
+#if (MFX_VERSION >= 1025)
+        mfxExtBuffer* extbuf = (bs) ? GetExtendedBuffer(bs->ExtParam, bs->NumExtParam, MFX_EXTBUFF_DECODE_ERROR_REPORT) : NULL;
+
+        if (extbuf)
+        {
+            ((mfxExtDecodeErrorReport *)extbuf)->ErrorTypes = 0;
+            src.SetExtBuffer(extbuf);
+        }
+#endif
+
         for (;;)
         {
             if (m_FrameAllocator->FindFreeSurface() == -1)
diff --git a/_studio/shared/umc/codec/h265_dec/src/umc_h265_mfx_utils.cpp b/_studio/shared/umc/codec/h265_dec/src/umc_h265_mfx_utils.cpp
index 4cc5dd5..db876f4 100644
--- a/_studio/shared/umc/codec/h265_dec/src/umc_h265_mfx_utils.cpp
+++ b/_studio/shared/umc/codec/h265_dec/src/umc_h265_mfx_utils.cpp
@@ -488,6 +488,13 @@ UMC::Status HeadersAnalyzer::DecodeHeader(UMC::MediaData * data, mfxBitstream *b
     H265SeqParamSet* first_sps = 0;
     notifier0<H265SeqParamSet> sps_guard(&H265Slice::DecrementReference);
 
+#if (MFX_VERSION >= 1025)
+    mfxExtBuffer* extbuf = (bs) ? GetExtendedBuffer(bs->ExtParam, bs->NumExtParam, MFX_EXTBUFF_DECODE_ERROR_REPORT) : NULL;
+
+    if (extbuf)
+        data->SetAuxInfo(extbuf, extbuf->BufferSz, extbuf->BufferId);
+#endif
+
     UMC::Status umcRes = UMC::UMC_ERR_NOT_ENOUGH_DATA;
     for ( ; data->GetDataSize() > 3; )
     {
diff --git a/_studio/shared/umc/codec/h265_dec/src/umc_h265_task_supplier.cpp b/_studio/shared/umc/codec/h265_dec/src/umc_h265_task_supplier.cpp
index 9062568..e220095 100755
--- a/_studio/shared/umc/codec/h265_dec/src/umc_h265_task_supplier.cpp
+++ b/_studio/shared/umc/codec/h265_dec/src/umc_h265_task_supplier.cpp
@@ -47,6 +47,21 @@
 namespace UMC_HEVC_DECODER
 {
 
+#if (MFX_VERSION >= 1025)
+inline void SetDecodeErrorTypes(NalUnitType nalUnit, mfxExtDecodeErrorReport *pDecodeErrorReport)
+{
+    if (!pDecodeErrorReport)
+        return;
+
+    switch (nalUnit)
+    {
+        case NAL_UT_SPS: pDecodeErrorReport->ErrorTypes |= MFX_ERROR_SPS; break;
+        case NAL_UT_PPS: pDecodeErrorReport->ErrorTypes |= MFX_ERROR_PPS; break;
+        default: break;
+    };
+}
+#endif
+
 const uint32_t levelIndexArray[] = {
     H265_LEVEL_1,
     H265_LEVEL_2,
@@ -1662,6 +1677,15 @@ UMC::Status TaskSupplier_H265::ProcessNalUnit(UMC::MediaDataEx *nalUnit)
     case NAL_UT_SPS:
     case NAL_UT_PPS:
         umcRes = DecodeHeaders(nalUnit);
+        {
+#if (MFX_VERSION >= 1025)
+            UMC::MediaData::AuxInfo* aux = (nalUnit) ? nalUnit->GetAuxInfo(MFX_EXTBUFF_DECODE_ERROR_REPORT) : NULL;
+            mfxExtDecodeErrorReport* pDecodeErrorReport = (aux) ? reinterpret_cast<mfxExtDecodeErrorReport*>(aux->ptr) : NULL;
+            if (pDecodeErrorReport && umcRes == UMC::UMC_ERR_INVALID_STREAM)
+                SetDecodeErrorTypes(unitType, pDecodeErrorReport);
+#endif
+        }
+
         break;
 
     case NAL_UT_SEI:
@@ -1703,6 +1727,11 @@ UMC::Status TaskSupplier_H265::AddOneFrame(UMC::MediaData * pSource)
 
         UMC::MediaDataEx::_MediaDataEx* pMediaDataEx = nalUnit->GetExData();
 
+#if (MFX_VERSION >= 1025)
+        UMC::MediaData::AuxInfo* aux = (pSource) ? pSource->GetAuxInfo(MFX_EXTBUFF_DECODE_ERROR_REPORT) : NULL;
+        mfxExtDecodeErrorReport* pDecodeErrorReport = (aux) ? reinterpret_cast<mfxExtDecodeErrorReport*>(aux->ptr) : NULL;
+#endif
+
         for (int32_t i = 0; i < (int32_t)pMediaDataEx->count; i++, pMediaDataEx->index ++)
         {
             if (m_checkCRAInsideResetProcess)
@@ -1755,7 +1784,13 @@ UMC::Status TaskSupplier_H265::AddOneFrame(UMC::MediaData * pSource)
                 case NAL_UT_VPS:
                 case NAL_UT_SPS:
                 case NAL_UT_PPS:
-                    DecodeHeaders(nalUnit);
+                    {
+                        UMC::Status sts = DecodeHeaders(nalUnit);
+#if (MFX_VERSION >= 1025)
+                        if (pDecodeErrorReport && sts == UMC::UMC_ERR_INVALID_STREAM)
+                            SetDecodeErrorTypes((NalUnitType)pMediaDataEx->values[i], pDecodeErrorReport);
+#endif
+                    }
                     break;
 
                 default:
@@ -1822,6 +1857,10 @@ UMC::Status TaskSupplier_H265::AddOneFrame(UMC::MediaData * pSource)
                             moveToSpsOffset = pSource->GetDataSize() + size + 3;
                             continue;
                         }
+#if (MFX_VERSION >= 1025)
+                        if (pDecodeErrorReport && umsRes == UMC::UMC_ERR_INVALID_STREAM)
+                            SetDecodeErrorTypes(nut, pDecodeErrorReport);
+#endif
 
                         return umsRes;
                     }
-- 
2.7.4

