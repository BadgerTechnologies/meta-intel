From 64250fb3e73c1977067381c70aeffbaa980f4136 Mon Sep 17 00:00:00 2001
From: jinchung <jin.chung.teng@intel.com>
Date: Fri, 28 May 2021 11:34:01 +0800
Subject: [PATCH] Adding Wayland support to legacy tools

Upstream-Status: Submitted
https://github.com/oneapi-src/oneVPL/pull/6

Signed-off-by: jinchung <jin.chung.teng@intel.com>
---
 tools/legacy/CMakeLists.txt                        |   1 +
 tools/legacy/sample_common/CMakeLists.txt          |   8 +
 tools/legacy/sample_common/src/vaapi_device.cpp    |   2 +-
 tools/legacy/sample_misc/wayland/CMakeLists.txt    |  29 ++
 .../sample_misc/wayland/include/class_wayland.h    | 160 +++++++
 .../sample_misc/wayland/include/listener_wayland.h |  66 +++
 .../wayland/include/wayland-drm-client-protocol.h  | 235 ++++++++++
 .../sample_misc/wayland/src/class_wayland.cpp      | 500 +++++++++++++++++++++
 .../sample_misc/wayland/src/listener_wayland.cpp   | 105 +++++
 .../sample_misc/wayland/src/wayland-drm-protocol.c |  84 ++++
 10 files changed, 1189 insertions(+), 1 deletion(-)
 create mode 100644 tools/legacy/sample_misc/wayland/CMakeLists.txt
 create mode 100644 tools/legacy/sample_misc/wayland/include/class_wayland.h
 create mode 100644 tools/legacy/sample_misc/wayland/include/listener_wayland.h
 create mode 100644 tools/legacy/sample_misc/wayland/include/wayland-drm-client-protocol.h
 create mode 100644 tools/legacy/sample_misc/wayland/src/class_wayland.cpp
 create mode 100644 tools/legacy/sample_misc/wayland/src/listener_wayland.cpp
 create mode 100644 tools/legacy/sample_misc/wayland/src/wayland-drm-protocol.c

diff --git a/tools/legacy/CMakeLists.txt b/tools/legacy/CMakeLists.txt
index 165a5b2..1d4af73 100644
--- a/tools/legacy/CMakeLists.txt
+++ b/tools/legacy/CMakeLists.txt
@@ -11,3 +11,4 @@ add_subdirectory(sample_common)
 add_subdirectory(sample_decode)
 add_subdirectory(sample_vpp)
 add_subdirectory(sample_encode)
+add_subdirectory(sample_misc/wayland)
diff --git a/tools/legacy/sample_common/CMakeLists.txt b/tools/legacy/sample_common/CMakeLists.txt
index db4de3d..4f04226 100644
--- a/tools/legacy/sample_common/CMakeLists.txt
+++ b/tools/legacy/sample_common/CMakeLists.txt
@@ -70,6 +70,7 @@ if(UNIX)
   pkg_check_modules(PKG_LIBDRM libdrm)
   pkg_check_modules(PKG_X11 x11)
   pkg_check_modules(PKG_LIBVA_X11 libva-x11>=1.10.0)
+  pkg_check_modules(PKG_WAYLAND_CLIENT wayland-client)
   if(PKG_LIBVA_FOUND)
     target_compile_definitions(${TARGET} PUBLIC -DLIBVA_SUPPORT)
     target_include_directories(${TARGET} PUBLIC ${PKG_LIBVA_INCLUDE_DIRS})
@@ -88,6 +89,13 @@ if(UNIX)
   else()
     message(WARNING "x11 modules not found: building without libVA X11 support")
   endif()
+  if(PKG_WAYLAND_CLIENT_FOUND)
+    target_compile_definitions(${TARGET} PUBLIC -DLIBVA_WAYLAND_SUPPORT)
+    target_include_directories(${TARGET} PUBLIC ${PKG_WAYLAND_CLIENT_LIBRARY_DIRS})
+    target_include_directories(${TARGET} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/../sample_misc/wayland/include)
+  else()
+    message(WARNING "wayland modules not found: building without Wayland support")
+  endif()
 
   target_link_libraries(${TARGET} ${CMAKE_DL_LIBS})
 
diff --git a/tools/legacy/sample_common/src/vaapi_device.cpp b/tools/legacy/sample_common/src/vaapi_device.cpp
index 3f6d3ba..b034376 100644
--- a/tools/legacy/sample_common/src/vaapi_device.cpp
+++ b/tools/legacy/sample_common/src/vaapi_device.cpp
@@ -396,7 +396,7 @@ mfxStatus CVAAPIDeviceWayland::RenderFrame(mfxFrameSurface1* pSurface,
         return mfx_res;
     }
 
-    m_Wayland->RenderBuffer(m_wl_buffer, pSurface->Info.CropW, pSurface->Info.CropH);
+    m_Wayland->RenderBuffer(m_wl_buffer, pSurface);
 
     return mfx_res;
 }
diff --git a/tools/legacy/sample_misc/wayland/CMakeLists.txt b/tools/legacy/sample_misc/wayland/CMakeLists.txt
new file mode 100644
index 0000000..95057d4
--- /dev/null
+++ b/tools/legacy/sample_misc/wayland/CMakeLists.txt
@@ -0,0 +1,29 @@
+if (NOT PKG_WAYLAND_CLIENT_FOUND)
+    return()
+endif()
+
+set(TARGET mfx_wayland)
+
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(PKG_WAYLAND_CLIENT wayland-client)
+pkg_check_modules(PKG_LIBVA libva libva-drm)
+pkg_check_modules(PKG_LIBDRM libdrm)
+
+include_directories (
+  ${CMAKE_CURRENT_SOURCE_DIR}/../../sample_common/include
+  ${CMAKE_CURRENT_SOURCE_DIR}/include
+  ${CMAKE_CURRENT_SOURCE_DIR}/../../../../api/vpl
+  ${PKG_LIBDRM_INCLUDE_DIRS}
+  ${PKG_WAYLAND_CLIENT_LIBRARY_DIRS}
+)
+
+add_definitions(-DLIBVA_WAYLAND_SUPPORT)
+add_library(${TARGET} SHARED "")
+target_sources(${TARGET} PRIVATE 
+  ${CMAKE_CURRENT_SOURCE_DIR}/src/class_wayland.cpp  
+  ${CMAKE_CURRENT_SOURCE_DIR}/src/listener_wayland.cpp 
+  ${CMAKE_CURRENT_SOURCE_DIR}/src/wayland-drm-protocol.c)
+
+target_link_libraries(${TARGET} sample_common wayland-client va drm drm_intel)
+
+install( TARGETS ${TARGETS} LIBRARY DESTINATION ${CMAKE_INSTALL_BINDIR} )
diff --git a/tools/legacy/sample_misc/wayland/include/class_wayland.h b/tools/legacy/sample_misc/wayland/include/class_wayland.h
new file mode 100644
index 0000000..1c64f9c
--- /dev/null
+++ b/tools/legacy/sample_misc/wayland/include/class_wayland.h
@@ -0,0 +1,160 @@
+/******************************************************************************\
+Copyright (c) 2005-2019, Intel Corporation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+This sample was distributed or derived from the Intel's Media Samples package.
+The original version of this sample may be obtained from https://software.intel.com/en-us/intel-media-server-studio
+or https://software.intel.com/en-us/media-client-solutions-support.
+\**********************************************************************************/
+
+#ifndef WAYLAND_CLASS_H
+#define WAYLAND_CLASS_H
+
+#if defined(LIBVA_WAYLAND_SUPPORT)
+
+extern "C"
+{
+    #include <intel_bufmgr.h>
+}
+#include <poll.h>
+#include <wayland-client.h>
+#include <list>
+#include "wayland-drm-client-protocol.h"
+#include "vpl/mfxstructures.h"
+#include "mfx_buffering.h"
+#include "sample_defs.h"
+
+typedef struct buffer wld_buffer;
+
+/* ShmPool Struct */
+struct ShmPool {
+    int fd;
+    uint32_t *memory;
+    unsigned capacity;
+    unsigned size;
+};
+
+class Wayland: public CBuffering {
+    public:
+        Wayland();
+        virtual ~Wayland();
+        virtual bool InitDisplay();
+        virtual bool CreateSurface();
+        virtual void FreeSurface();
+        virtual void SetRenderWinPos(int x, int y);
+        virtual void RenderBuffer(struct wl_buffer *buffer
+            , mfxFrameSurface1 *surface);
+        virtual void RenderBufferWinPosSize(struct wl_buffer *buffer
+            , int x
+            , int y
+            , int32_t width
+            , int32_t height);
+        bool CreateShmPool(int fd, int32_t size, int prot);
+        void FreeShmPool();
+        /* Create wl_buffer from shm_pool */
+        struct wl_buffer * CreateShmBuffer(unsigned width
+            , unsigned height
+            , unsigned stride
+            , uint32_t PIXEL_FORMAT_ID);
+        void FreeShmBuffer(struct wl_buffer *buffer);
+        int Dispatch();
+        struct wl_buffer * CreatePlanarBuffer(uint32_t name
+            , int32_t width
+            , int32_t height
+            , uint32_t format
+            , int32_t offsets[3]
+            , int32_t pitches[3]);
+        virtual struct wl_buffer * CreatePrimeBuffer(uint32_t name
+            , int32_t width
+            , int32_t height
+            , uint32_t format
+            , int32_t offsets[3]
+            , int32_t pitches[3]);
+        struct wl_display * GetDisplay() { return m_display; }
+        struct wl_registry * GetRegistry() { return m_registry; }
+        struct wl_compositor * GetCompositor() { return m_compositor; }
+        struct wl_shell * GetShell() { return m_shell; }
+        struct wl_drm * GetDrm() { return m_drm; }
+        struct wl_shm * GetShm() { return m_shm; };
+        struct wl_shm_pool * GetShmPool() { return m_pool; }
+        struct wl_surface * GetSurface() { return m_surface; }
+        struct wl_shell_surface * GetShellSurface() { return m_shell_surface; }
+        struct wl_callback * GetCallback() { return m_callback; }
+        void SetCompositor(struct wl_compositor *compositor)
+        {
+            m_compositor = compositor;
+        }
+        void SetShell(struct wl_shell *shell)
+        {
+            m_shell = shell;
+        }
+        void SetShm(struct wl_shm *shm)
+        {
+            m_shm = shm;
+        }
+        void SetDrm(struct wl_drm *drm)
+        {
+            m_drm = drm;
+        }
+        void DrmHandleDevice(const char* device);
+        void DrmHandleAuthenticated();
+        void RegistryGlobal(struct wl_registry *registry
+            , uint32_t name
+            , const char *interface
+            , uint32_t version);
+        void DisplayFlush()
+        {
+            wl_display_flush(m_display);
+        }
+        virtual int DisplayRoundtrip();
+        void DestroyCallback();
+        virtual void Sync();
+        virtual void SetPerfMode(bool perf_mode);
+        void AddBufferToList(wld_buffer *buffer);
+        void RemoveBufferFromList(struct wl_buffer *buffer);
+        void DestroyBufferList();
+    private:
+        //no copies allowed
+        Wayland(const Wayland &);
+        void operator = (const Wayland&);
+
+        struct wl_display *m_display;
+        struct wl_registry *m_registry;
+        struct wl_compositor *m_compositor;
+        struct wl_shell *m_shell;
+        struct wl_drm *m_drm;
+        struct wl_shm *m_shm;
+        struct wl_shm_pool *m_pool;
+        struct wl_surface *m_surface;
+        struct wl_shell_surface *m_shell_surface;
+        struct wl_callback *m_callback;
+        struct wl_event_queue *m_event_queue;
+        volatile int m_pending_frame;
+        struct ShmPool *m_shm_pool;
+        int m_display_fd;
+        int m_fd;
+        struct pollfd m_poll;
+        drm_intel_bufmgr *m_bufmgr;
+        char *m_device_name;
+        int m_x, m_y;
+        bool m_perf_mode;
+    protected:
+        std::list<wld_buffer*> m_buffers_list;
+};
+
+extern "C" Wayland* WaylandCreate();
+extern "C" void WaylandDestroy(Wayland *pWld);
+
+#endif //LIBVA_WAYLAND_SUPPORT
+
+#endif /* WAYLAND_CLASS_H */
diff --git a/tools/legacy/sample_misc/wayland/include/listener_wayland.h b/tools/legacy/sample_misc/wayland/include/listener_wayland.h
new file mode 100644
index 0000000..1bbaa91
--- /dev/null
+++ b/tools/legacy/sample_misc/wayland/include/listener_wayland.h
@@ -0,0 +1,66 @@
+/******************************************************************************\
+Copyright (c) 2005-2019, Intel Corporation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+This sample was distributed or derived from the Intel's Media Samples package.
+The original version of this sample may be obtained from https://software.intel.com/en-us/intel-media-server-studio
+or https://software.intel.com/en-us/media-client-solutions-support.
+\**********************************************************************************/
+
+#ifndef LISTENER_WAYLAND_H
+#define LISTENER_WAYLAND_H
+
+#include "class_wayland.h"
+
+/* drm listeners */
+void drm_handle_device(void *data
+    , struct wl_drm *drm
+    , const char *device);
+
+void drm_handle_format(void *data
+    , struct wl_drm *drm
+    , uint32_t format);
+
+void drm_handle_authenticated(void *data
+    , struct wl_drm *drm);
+
+void drm_handle_capabilities(void *data
+    , struct wl_drm *drm
+    , uint32_t value);
+
+/* registry listeners */
+void registry_handle_global(void *data
+    , struct wl_registry *registry
+    , uint32_t name
+    , const char *interface
+    , uint32_t version);
+
+void remove_registry_global(void *data
+    , struct wl_registry *regsitry
+    , uint32_t name);
+
+/* surface listener */
+void shell_surface_ping(void *data
+    , struct wl_shell_surface *shell_surface
+    , uint32_t serial);
+
+void shell_surface_configure(void *data
+    , struct wl_shell_surface *shell_surface
+    , uint32_t edges
+    , int32_t width
+    , int32_t height);
+
+void handle_done(void *data, struct wl_callback *callback, uint32_t time);
+
+void buffer_release(void *data, struct wl_buffer *buffer);
+#endif /* LISTENER_WAYLAND_H */
diff --git a/tools/legacy/sample_misc/wayland/include/wayland-drm-client-protocol.h b/tools/legacy/sample_misc/wayland/include/wayland-drm-client-protocol.h
new file mode 100644
index 0000000..e11b35d
--- /dev/null
+++ b/tools/legacy/sample_misc/wayland/include/wayland-drm-client-protocol.h
@@ -0,0 +1,235 @@
+/*
+ * Copyright � 2008-2011 Kristian H�gsberg
+ * Copyright � 2010-2011 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that\n the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ */
+
+#ifndef DRM_CLIENT_PROTOCOL_H
+#define DRM_CLIENT_PROTOCOL_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+struct wl_client;
+struct wl_resource;
+
+struct wl_drm;
+
+extern const struct wl_interface wl_drm_interface;
+
+#ifndef WL_DRM_ERROR_ENUM
+#define WL_DRM_ERROR_ENUM
+enum wl_drm_error {
+    WL_DRM_ERROR_AUTHENTICATE_FAIL = 0,
+    WL_DRM_ERROR_INVALID_FORMAT = 1,
+    WL_DRM_ERROR_INVALID_NAME = 2,
+};
+#endif /* WL_DRM_ERROR_ENUM */
+
+#ifndef WL_DRM_FORMAT_ENUM
+#define WL_DRM_FORMAT_ENUM
+enum wl_drm_format {
+    WL_DRM_FORMAT_C8 = 0x20203843,
+    WL_DRM_FORMAT_RGB332 = 0x38424752,
+    WL_DRM_FORMAT_BGR233 = 0x38524742,
+    WL_DRM_FORMAT_XRGB4444 = 0x32315258,
+    WL_DRM_FORMAT_XBGR4444 = 0x32314258,
+    WL_DRM_FORMAT_RGBX4444 = 0x32315852,
+    WL_DRM_FORMAT_BGRX4444 = 0x32315842,
+    WL_DRM_FORMAT_ARGB4444 = 0x32315241,
+    WL_DRM_FORMAT_ABGR4444 = 0x32314241,
+    WL_DRM_FORMAT_RGBA4444 = 0x32314152,
+    WL_DRM_FORMAT_BGRA4444 = 0x32314142,
+    WL_DRM_FORMAT_XRGB1555 = 0x35315258,
+    WL_DRM_FORMAT_XBGR1555 = 0x35314258,
+    WL_DRM_FORMAT_RGBX5551 = 0x35315852,
+    WL_DRM_FORMAT_BGRX5551 = 0x35315842,
+    WL_DRM_FORMAT_ARGB1555 = 0x35315241,
+    WL_DRM_FORMAT_ABGR1555 = 0x35314241,
+    WL_DRM_FORMAT_RGBA5551 = 0x35314152,
+    WL_DRM_FORMAT_BGRA5551 = 0x35314142,
+    WL_DRM_FORMAT_RGB565 = 0x36314752,
+    WL_DRM_FORMAT_BGR565 = 0x36314742,
+    WL_DRM_FORMAT_RGB888 = 0x34324752,
+    WL_DRM_FORMAT_BGR888 = 0x34324742,
+    WL_DRM_FORMAT_XRGB8888 = 0x34325258,
+    WL_DRM_FORMAT_XBGR8888 = 0x34324258,
+    WL_DRM_FORMAT_RGBX8888 = 0x34325852,
+    WL_DRM_FORMAT_BGRX8888 = 0x34325842,
+    WL_DRM_FORMAT_ARGB8888 = 0x34325241,
+    WL_DRM_FORMAT_ABGR8888 = 0x34324241,
+    WL_DRM_FORMAT_RGBA8888 = 0x34324152,
+    WL_DRM_FORMAT_BGRA8888 = 0x34324142,
+    WL_DRM_FORMAT_XRGB2101010 = 0x30335258,
+    WL_DRM_FORMAT_XBGR2101010 = 0x30334258,
+    WL_DRM_FORMAT_RGBX1010102 = 0x30335852,
+    WL_DRM_FORMAT_BGRX1010102 = 0x30335842,
+    WL_DRM_FORMAT_ARGB2101010 = 0x30335241,
+    WL_DRM_FORMAT_ABGR2101010 = 0x30334241,
+    WL_DRM_FORMAT_RGBA1010102 = 0x30334152,
+    WL_DRM_FORMAT_BGRA1010102 = 0x30334142,
+    WL_DRM_FORMAT_YUYV = 0x56595559,
+    WL_DRM_FORMAT_YVYU = 0x55595659,
+    WL_DRM_FORMAT_UYVY = 0x59565955,
+    WL_DRM_FORMAT_VYUY = 0x59555956,
+    WL_DRM_FORMAT_AYUV = 0x56555941,
+    WL_DRM_FORMAT_NV12 = 0x3231564e,
+    WL_DRM_FORMAT_NV21 = 0x3132564e,
+    WL_DRM_FORMAT_NV16 = 0x3631564e,
+    WL_DRM_FORMAT_NV61 = 0x3136564e,
+    WL_DRM_FORMAT_YUV410 = 0x39565559,
+    WL_DRM_FORMAT_YVU410 = 0x39555659,
+    WL_DRM_FORMAT_YUV411 = 0x31315559,
+    WL_DRM_FORMAT_YVU411 = 0x31315659,
+    WL_DRM_FORMAT_YUV420 = 0x32315559,
+    WL_DRM_FORMAT_YVU420 = 0x32315659,
+    WL_DRM_FORMAT_YUV422 = 0x36315559,
+    WL_DRM_FORMAT_YVU422 = 0x36315659,
+    WL_DRM_FORMAT_YUV444 = 0x34325559,
+    WL_DRM_FORMAT_YVU444 = 0x34325659,
+};
+#endif /* WL_DRM_FORMAT_ENUM */
+
+#ifndef WL_DRM_CAPABILITY_ENUM
+#define WL_DRM_CAPABILITY_ENUM
+/**
+ * wl_drm_capability - wl_drm capability bitmask
+ * @WL_DRM_CAPABILITY_PRIME: wl_drm prime available
+ *
+ * Bitmask of capabilities.
+ */
+enum wl_drm_capability {
+    WL_DRM_CAPABILITY_PRIME = 1,
+};
+#endif /* WL_DRM_CAPABILITY_ENUM */
+
+struct wl_drm_listener {
+    /**
+     * device - (none)
+     * @name: (none)
+     */
+    void (*device)(void *data,
+               struct wl_drm *wl_drm,
+               const char *name);
+    /**
+     * format - (none)
+     * @format: (none)
+     */
+    void (*format)(void *data,
+               struct wl_drm *wl_drm,
+               uint32_t format);
+    /**
+     * authenticated - (none)
+     */
+    void (*authenticated)(void *data,
+                  struct wl_drm *wl_drm);
+    /**
+     * capabilities - (none)
+     * @value: (none)
+     */
+    void (*capabilities)(void *data,
+                 struct wl_drm *wl_drm,
+                 uint32_t value);
+};
+
+static inline int
+wl_drm_add_listener(struct wl_drm *wl_drm,
+            const struct wl_drm_listener *listener, void *data)
+{
+    return wl_proxy_add_listener((struct wl_proxy *) wl_drm,
+                     (void (**)(void)) listener, data);
+}
+
+#define WL_DRM_AUTHENTICATE    0
+#define WL_DRM_CREATE_BUFFER    1
+#define WL_DRM_CREATE_PLANAR_BUFFER    2
+#define WL_DRM_CREATE_PRIME_BUFFER    3
+
+static inline void
+wl_drm_set_user_data(struct wl_drm *wl_drm, void *user_data)
+{
+    wl_proxy_set_user_data((struct wl_proxy *) wl_drm, user_data);
+}
+
+static inline void *
+wl_drm_get_user_data(struct wl_drm *wl_drm)
+{
+    return wl_proxy_get_user_data((struct wl_proxy *) wl_drm);
+}
+
+static inline void
+wl_drm_destroy(struct wl_drm *wl_drm)
+{
+    wl_proxy_destroy((struct wl_proxy *) wl_drm);
+}
+
+static inline void
+wl_drm_authenticate(struct wl_drm *wl_drm, uint32_t id)
+{
+    wl_proxy_marshal((struct wl_proxy *) wl_drm,
+             WL_DRM_AUTHENTICATE, id);
+}
+
+static inline struct wl_buffer *
+wl_drm_create_buffer(struct wl_drm *wl_drm, uint32_t name, int32_t width, int32_t height, uint32_t stride, uint32_t format)
+{
+    struct wl_proxy *id;
+
+    id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_drm,
+             WL_DRM_CREATE_BUFFER, &wl_buffer_interface, NULL, name, width, height, stride, format);
+
+    return (struct wl_buffer *) id;
+}
+
+static inline struct wl_buffer *
+wl_drm_create_planar_buffer(struct wl_drm *wl_drm, uint32_t name, int32_t width, int32_t height, uint32_t format, int32_t offset0, int32_t stride0, int32_t offset1, int32_t stride1, int32_t offset2, int32_t stride2)
+{
+    struct wl_proxy *id;
+
+    id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_drm,
+             WL_DRM_CREATE_PLANAR_BUFFER, &wl_buffer_interface, NULL, name, width, height, format, offset0, stride0, offset1, stride1, offset2, stride2);
+
+    return (struct wl_buffer *) id;
+}
+
+static inline struct wl_buffer *
+wl_drm_create_prime_buffer(struct wl_drm *wl_drm, int32_t name, int32_t width, int32_t height, uint32_t format, int32_t offset0, int32_t stride0, int32_t offset1, int32_t stride1, int32_t offset2, int32_t stride2)
+{
+    struct wl_proxy *id;
+
+    id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_drm,
+             WL_DRM_CREATE_PRIME_BUFFER, &wl_buffer_interface, NULL, name, width, height, format, offset0, stride0, offset1, stride1, offset2, stride2);
+
+    return (struct wl_buffer *) id;
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/tools/legacy/sample_misc/wayland/src/class_wayland.cpp b/tools/legacy/sample_misc/wayland/src/class_wayland.cpp
new file mode 100644
index 0000000..2bafdb2
--- /dev/null
+++ b/tools/legacy/sample_misc/wayland/src/class_wayland.cpp
@@ -0,0 +1,500 @@
+/******************************************************************************\
+Copyright (c) 2005-2019, Intel Corporation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+This sample was distributed or derived from the Intel's Media Samples package.
+The original version of this sample may be obtained from https://software.intel.com/en-us/intel-media-server-studio
+or https://software.intel.com/en-us/media-client-solutions-support.
+\**********************************************************************************/
+
+#include <iostream>
+#include <exception>
+#include <cstring>
+#include <fcntl.h>
+#include <unistd.h>
+#include <poll.h>
+#include <sys/mman.h>
+extern "C" {
+#include <drm.h>
+#include <xf86drm.h>
+#include <intel_bufmgr.h>
+}
+#include "class_wayland.h"
+#include "listener_wayland.h"
+#include "wayland-drm-client-protocol.h"
+
+#define BATCH_SIZE 0x80000
+
+struct buffer {
+   struct wl_buffer *buffer;
+   mfxFrameSurface1 *pInSurface;
+};
+
+static const struct wl_callback_listener frame_listener = {
+    handle_done
+};
+
+static const struct wl_buffer_listener buffer_listener = {
+    buffer_release
+};
+
+Wayland::Wayland()
+    : m_display(NULL)
+    , m_registry(NULL)
+    , m_compositor(NULL)
+    , m_shell(NULL)
+    , m_drm(NULL)
+    , m_shm(NULL)
+    , m_pool(NULL)
+    , m_surface(NULL)
+    , m_shell_surface(NULL)
+    , m_callback(NULL)
+    , m_event_queue(NULL)
+    , m_pending_frame(0)
+    , m_shm_pool(NULL)
+    , m_display_fd(-1)
+    , m_fd(-1)
+    , m_bufmgr(NULL)
+    , m_device_name(NULL)
+    , m_x(0), m_y(0)
+    , m_perf_mode(false)
+{
+    std::memset(&m_poll, 0, sizeof(m_poll));
+}
+
+bool Wayland::InitDisplay()
+{
+    static const struct wl_registry_listener registry_listener = {
+        .global = registry_handle_global,
+        .global_remove = remove_registry_global
+    };
+
+    m_display = wl_display_connect(NULL);
+    if (NULL == m_display) {
+        std::cout << "Error: Cannot connect to wayland display\n";
+        return false;
+    }
+    m_registry = wl_display_get_registry(m_display);
+    wl_registry_add_listener(m_registry
+        , &registry_listener
+        , this);
+
+    m_display_fd = wl_display_get_fd(m_display);
+    wl_display_roundtrip(m_display);
+    wl_display_roundtrip(m_display);
+    m_event_queue = wl_display_create_queue(m_display);
+    if(NULL == m_event_queue)
+        return false;
+
+    m_poll.fd = m_display_fd;
+    m_poll.events = POLLIN;
+    return true;
+}
+
+int Wayland::DisplayRoundtrip()
+{
+    return wl_display_roundtrip(m_display);
+}
+
+bool Wayland::CreateSurface()
+{
+    static const struct wl_shell_surface_listener
+        shell_surface_listener = {
+            shell_surface_ping,
+            shell_surface_configure
+        };
+
+    m_surface = wl_compositor_create_surface(m_compositor);
+    if (NULL == m_surface)
+        return false;
+
+    m_shell_surface = wl_shell_get_shell_surface(m_shell
+        , m_surface);
+    if(NULL == m_shell_surface)
+    {
+        wl_surface_destroy(m_surface);
+        return false;
+    }
+
+    wl_shell_surface_add_listener(m_shell_surface
+        , &shell_surface_listener
+        , 0);
+    wl_shell_surface_set_toplevel(m_shell_surface);
+    wl_shell_surface_set_user_data(m_shell_surface, m_surface);
+    wl_surface_set_user_data(m_surface, NULL);
+    return true;
+}
+
+
+void Wayland::FreeSurface()
+{
+    if(NULL != m_shell_surface)
+        wl_shell_surface_destroy(m_shell_surface);
+    if(NULL != m_surface)
+        wl_surface_destroy(m_surface);
+}
+
+void Wayland::Sync()
+{
+    int ret;
+    while(NULL != m_callback)
+    {
+        while(wl_display_prepare_read_queue(m_display, m_event_queue) < 0)
+            wl_display_dispatch_queue_pending(m_display, m_event_queue);
+
+        wl_display_flush(m_display);
+
+        ret = poll(&m_poll,1,-1);
+        if(ret < 0 )
+            wl_display_cancel_read(m_display);
+        else
+        wl_display_read_events(m_display);
+        wl_display_dispatch_queue_pending(m_display, m_event_queue);
+    }
+}
+
+void Wayland::SetPerfMode(bool perf_mode)
+{
+    m_perf_mode = perf_mode;
+}
+
+void Wayland::SetRenderWinPos(int x, int y)
+{
+    m_x = x; m_y = y;
+}
+
+void Wayland::RenderBuffer(struct wl_buffer *buffer
+     , mfxFrameSurface1 *surface)
+{
+    wld_buffer *m_buffer = new wld_buffer;
+    if (m_buffer == NULL)
+      return;
+
+    m_buffer->buffer = buffer;
+    m_buffer->pInSurface = surface;
+
+    wl_surface_attach(m_surface, buffer, 0, 0);
+    wl_surface_damage(m_surface, m_x, m_y, surface->Info.CropW, surface->Info.CropH);
+
+    wl_proxy_set_queue((struct wl_proxy *) buffer, m_event_queue);
+
+    AddBufferToList(m_buffer);
+    wl_buffer_add_listener(buffer, &buffer_listener, this);
+    m_pending_frame=1;
+    if (m_perf_mode)
+        m_callback = wl_display_sync(m_display);
+    else
+    m_callback = wl_surface_frame(m_surface);
+    wl_callback_add_listener(m_callback, &frame_listener, this);
+    wl_proxy_set_queue((struct wl_proxy *) m_callback, m_event_queue);
+    wl_surface_commit(m_surface);
+    wl_display_dispatch_queue(m_display, m_event_queue);
+    /* Force a Sync before and after render to ensure client handles
+      wayland events in a timely fashion. This also fixes the one time
+      flicker issue on wl_shell_surface pointer enter */
+    Sync();
+
+}
+
+void Wayland::RenderBufferWinPosSize(struct wl_buffer *buffer
+    , int x
+    , int y
+    , int32_t width
+    , int32_t height)
+{
+    wl_surface_attach(m_surface, buffer, 0, 0);
+    wl_surface_damage(m_surface, x, y, width, height);
+
+    wl_proxy_set_queue((struct wl_proxy *) buffer, m_event_queue);
+
+    wl_buffer_add_listener(buffer, &buffer_listener, NULL);
+    m_pending_frame=1;
+    if (m_perf_mode)
+        m_callback = wl_display_sync(m_display);
+    else
+    m_callback = wl_surface_frame(m_surface);
+    wl_callback_add_listener(m_callback, &frame_listener, this);
+    wl_proxy_set_queue((struct wl_proxy *) m_callback, m_event_queue);
+    wl_surface_commit(m_surface);
+    wl_display_dispatch_queue(m_display, m_event_queue);
+}
+
+
+void Wayland::DestroyCallback()
+{
+    if(m_callback)
+    {
+        wl_callback_destroy(m_callback);
+        m_callback = NULL;
+        m_pending_frame=0;
+    }
+}
+
+//ShmPool
+bool  Wayland::CreateShmPool(int fd, int32_t size, int prot)
+{
+    m_shm_pool = new struct ShmPool;
+    if (NULL == m_shm_pool)
+        return false;
+
+    m_shm_pool->capacity = size;
+    m_shm_pool->size = 0;
+    m_shm_pool->fd = fd;
+
+    m_shm_pool->memory = static_cast<uint32_t*>(mmap(0
+        , size
+        , prot
+        , MAP_SHARED
+        , m_shm_pool->fd
+        , 0));
+    if (MAP_FAILED == m_shm_pool->memory)
+    {
+        delete m_shm_pool;
+        return false;
+    }
+
+    m_pool = wl_shm_create_pool(m_shm
+        , m_shm_pool->fd
+        , size);
+    if (NULL == m_pool)
+    {
+        munmap(m_shm_pool->memory, size);
+        delete m_shm_pool;
+        return false;
+    }
+    wl_shm_pool_set_user_data(m_pool, m_shm_pool);
+    return true;
+}
+
+
+void Wayland::FreeShmPool()
+{
+    wl_shm_pool_destroy(m_pool);
+    munmap(m_shm_pool->memory, m_shm_pool->capacity);
+    delete m_shm_pool;
+}
+
+
+struct wl_buffer * Wayland::CreateShmBuffer(unsigned width
+    , unsigned height
+    , unsigned stride
+    , uint32_t PIXEL_FORMAT_ID)
+{
+    struct wl_buffer *buffer;
+    buffer = wl_shm_pool_create_buffer(m_pool
+        , m_shm_pool->size*sizeof(uint32_t)
+        , width
+        , height
+        , stride
+        , PIXEL_FORMAT_ID);
+    if(NULL == buffer)
+    return NULL;
+
+    m_shm_pool->size += stride*height;
+    return buffer;
+}
+
+void Wayland::FreeShmBuffer(struct wl_buffer *buffer)
+{
+    wl_buffer_destroy(buffer);
+}
+
+int Wayland::Dispatch()
+{
+    return wl_display_dispatch(m_display);
+}
+
+struct wl_buffer * Wayland::CreatePlanarBuffer(uint32_t name
+    , int32_t width
+    , int32_t height
+    , uint32_t format
+    , int32_t offsets[3]
+    , int32_t pitches[3])
+{
+    struct wl_buffer * buffer = NULL;
+    if(NULL == m_drm)
+        return NULL;
+
+    buffer = wl_drm_create_planar_buffer(m_drm
+        , name
+        , width
+        , height
+        , format
+        , offsets[0]
+        , pitches[0]
+        , offsets[1]
+        , pitches[1]
+        , offsets[2]
+        , pitches[2]);
+    return buffer;
+}
+
+struct wl_buffer * Wayland::CreatePrimeBuffer(uint32_t name
+    , int32_t width
+    , int32_t height
+    , uint32_t format
+    , int32_t offsets[3]
+    , int32_t pitches[3])
+{
+    struct wl_buffer * buffer = NULL;
+    if(NULL == m_drm)
+        return NULL;
+
+    buffer = wl_drm_create_prime_buffer(m_drm
+            , name
+            , width
+            , height
+            , format
+            , offsets[0]
+            , pitches[0]
+            , offsets[1]
+            , pitches[1]
+            , offsets[2]
+            , pitches[2]);
+    return buffer;
+}
+
+Wayland::~Wayland()
+{
+    if(NULL != m_shell)
+        wl_shell_destroy(m_shell);
+    if(NULL != m_shm)
+        wl_shm_destroy(m_shm);
+    if(NULL != m_bufmgr) {
+        drm_intel_bufmgr_destroy(m_bufmgr);
+    }
+    if(NULL != m_compositor)
+        wl_compositor_destroy(m_compositor);
+    if(NULL != m_event_queue)
+        wl_event_queue_destroy(m_event_queue);
+    if(0 != m_buffers_list.size())
+        DestroyBufferList();
+    if(NULL != m_registry)
+        wl_registry_destroy(m_registry);
+    if(NULL != m_display)
+        wl_display_disconnect(m_display);
+    if(NULL != m_device_name)
+        delete m_device_name;
+}
+
+// Registry
+void Wayland::RegistryGlobal(struct wl_registry *registry
+    , uint32_t name
+    , const char *interface
+    , uint32_t version)
+{
+    if(0 == strcmp(interface, "wl_compositor"))
+        m_compositor = static_cast<wl_compositor*>
+            (wl_registry_bind(registry
+            , name
+            , &wl_compositor_interface
+            , version));
+    else if(0 == strcmp(interface, "wl_shell"))
+        m_shell = static_cast<wl_shell*>
+            (wl_registry_bind(registry
+            , name
+            , &wl_shell_interface
+            , version));
+    else if(0 == strcmp(interface, "wl_drm")) {
+        static const struct wl_drm_listener drm_listener = {
+            drm_handle_device,
+            drm_handle_format,
+            drm_handle_authenticated,
+            drm_handle_capabilities
+        };
+        m_drm = static_cast<wl_drm*>(wl_registry_bind(registry
+            , name
+            , &wl_drm_interface
+            , 2));
+            wl_drm_add_listener(m_drm, &drm_listener, this);
+    }
+}
+
+void Wayland::DrmHandleDevice(const char *name)
+{
+    m_device_name = strdup(name);
+    if (!m_device_name)
+        return;
+
+    drm_magic_t magic;
+    m_fd = open(m_device_name, O_RDWR | O_CLOEXEC);
+    if (-1 == m_fd) {
+        std::cout << "Error: Could not open " <<
+            m_device_name << "\n";
+        return;
+    }
+    int type = drmGetNodeTypeFromFd(m_fd);
+    if (type != DRM_NODE_RENDER) {
+        drmGetMagic(m_fd, &magic);
+        wl_drm_authenticate(m_drm, magic);
+    }
+}
+
+void Wayland::DrmHandleAuthenticated()
+{
+    m_bufmgr = drm_intel_bufmgr_gem_init(m_fd, BATCH_SIZE);
+}
+
+void Wayland::AddBufferToList(wld_buffer *buffer)
+{
+   if (buffer == NULL)
+     return;
+
+   if (buffer->pInSurface) {
+     msdkFrameSurface *surface = FindUsedSurface(buffer->pInSurface);
+     msdk_atomic_inc16(&(surface->render_lock));
+     m_buffers_list.push_back(buffer);
+   }
+}
+
+void Wayland::RemoveBufferFromList(struct wl_buffer *buffer)
+{
+   wld_buffer *m_buffer = NULL;
+   m_buffer = m_buffers_list.front();
+   if (NULL != m_buffer && (m_buffer->buffer == buffer)) {
+     if (m_buffer->pInSurface) {
+       msdkFrameSurface *surface = FindUsedSurface(m_buffer->pInSurface);
+       msdk_atomic_dec16(&(surface->render_lock));
+     }
+     m_buffer->buffer = NULL;
+     m_buffer->pInSurface = NULL;
+     m_buffers_list.pop_front();
+     delete m_buffer;
+   }
+}
+
+void Wayland::DestroyBufferList()
+{
+   wld_buffer *m_buffer = NULL;
+   while (!m_buffers_list.empty())
+   {
+      m_buffer = m_buffers_list.front();
+      if (m_buffer->pInSurface)
+      {
+        msdkFrameSurface *surface = FindUsedSurface(m_buffer->pInSurface);
+        msdk_atomic_dec16(&(surface->render_lock));
+      }
+      m_buffers_list.pop_front();
+      delete m_buffer;
+   }
+}
+
+Wayland* WaylandCreate()
+{
+    return new Wayland;
+}
+
+void WaylandDestroy(Wayland *pWld)
+{
+    delete pWld;
+}
diff --git a/tools/legacy/sample_misc/wayland/src/listener_wayland.cpp b/tools/legacy/sample_misc/wayland/src/listener_wayland.cpp
new file mode 100644
index 0000000..90f582a
--- /dev/null
+++ b/tools/legacy/sample_misc/wayland/src/listener_wayland.cpp
@@ -0,0 +1,105 @@
+/******************************************************************************\
+Copyright (c) 2005-2019, Intel Corporation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+This sample was distributed or derived from the Intel's Media Samples package.
+The original version of this sample may be obtained from https://software.intel.com/en-us/intel-media-server-studio
+or https://software.intel.com/en-us/media-client-solutions-support.
+\**********************************************************************************/
+
+#include <iostream>
+#include "listener_wayland.h"
+#include "class_wayland.h"
+
+/* drm listener */
+void drm_handle_device(void *data
+    , struct wl_drm *drm
+    , const char *device)
+{
+    Wayland *wayland = static_cast<Wayland*>(data);
+    wayland->DrmHandleDevice(device);
+}
+
+void drm_handle_format(void *data
+    , struct wl_drm *drm
+    , uint32_t format)
+{
+    /* NOT IMPLEMENTED */
+}
+
+void drm_handle_capabilities(void *data
+    , struct wl_drm *drm
+    , uint32_t value)
+{
+    /* NOT IMPLEMENTED */
+}
+
+void drm_handle_authenticated(void *data
+    , struct wl_drm *drm)
+{
+    Wayland *wayland = static_cast<Wayland*>(data);
+    wayland->DrmHandleAuthenticated();
+}
+
+/* registry listener */
+void registry_handle_global(void *data
+    , struct wl_registry *registry
+    , uint32_t name
+    , const char *interface
+    , uint32_t version)
+{
+    Wayland *wayland = static_cast<Wayland*>(data);
+    wayland->RegistryGlobal(registry
+        , name
+        , interface
+        , version);
+}
+
+void remove_registry_global(void *data
+    , struct wl_registry *registy
+    , uint32_t name)
+{
+    /* NOT IMPLEMENTED */
+}
+
+
+/* surface listener */
+void shell_surface_ping(void *data
+    , struct wl_shell_surface *shell_surface
+    , uint32_t serial)
+{
+    wl_shell_surface_pong(shell_surface, serial);
+}
+
+void shell_surface_configure(void *data
+    , struct wl_shell_surface *shell_surface
+    , uint32_t edges
+    , int32_t width
+    , int32_t height)
+{
+    /* NOT IMPLEMENTED */
+}
+
+void handle_done(void *data, struct wl_callback *callback, uint32_t time)
+{
+    Wayland *wayland = static_cast<Wayland*>(data);
+    wayland->DestroyCallback();
+}
+
+void buffer_release(void *data, struct wl_buffer *buffer)
+{
+    Wayland *wayland = static_cast<Wayland*>(data);
+    wayland->RemoveBufferFromList(buffer);
+    wl_buffer_destroy(buffer);
+    buffer = NULL;
+}
diff --git a/tools/legacy/sample_misc/wayland/src/wayland-drm-protocol.c b/tools/legacy/sample_misc/wayland/src/wayland-drm-protocol.c
new file mode 100644
index 0000000..8e1fd50
--- /dev/null
+++ b/tools/legacy/sample_misc/wayland/src/wayland-drm-protocol.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright � 2008-2011 Kristian H�gsberg
+ * Copyright � 2010-2011 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that\n the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_buffer_interface;
+
+static const struct wl_interface *types[] = {
+    NULL,
+    &wl_buffer_interface,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    &wl_buffer_interface,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    &wl_buffer_interface,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+};
+
+static const struct wl_message wl_drm_requests[] = {
+    { "authenticate", "u", types + 0 },
+    { "create_buffer", "nuiiuu", types + 1 },
+    { "create_planar_buffer", "nuiiuiiiiii", types + 7 },
+    { "create_prime_buffer", "2nhiiuiiiiii", types + 18 },
+};
+
+static const struct wl_message wl_drm_events[] = {
+    { "device", "s", types + 0 },
+    { "format", "u", types + 0 },
+    { "authenticated", "", types + 0 },
+    { "capabilities", "u", types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_drm_interface = {
+    "wl_drm", 2,
+    4, wl_drm_requests,
+    4, wl_drm_events,
+};
+
-- 
2.7.4

